{
  "version": 3,
  "sources": ["../../../../../storybook/dist/_browser-chunks/chunk-GFLS4VP3.js", "../../../../../storybook/dist/_browser-chunks/chunk-AIOS4NGK.js", "../../../../../storybook/dist/_browser-chunks/chunk-VYJQ7RU5.js"],
  "sourcesContent": ["// ../node_modules/es-toolkit/dist/predicate/isPlainObject.mjs\nfunction isPlainObject(value) {\n  if (!value || typeof value != \"object\")\n    return !1;\n  let proto = Object.getPrototypeOf(value);\n  return proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null ? Object.prototype.toString.call(value) === \"[object Object]\" : !1;\n}\n\n// ../node_modules/es-toolkit/dist/predicate/isPrimitive.mjs\nfunction isPrimitive(value) {\n  return value == null || typeof value != \"object\" && typeof value != \"function\";\n}\n\n// ../node_modules/es-toolkit/dist/predicate/isTypedArray.mjs\nfunction isTypedArray(x) {\n  return ArrayBuffer.isView(x) && !(x instanceof DataView);\n}\n\n// ../node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs\nfunction getSymbols(object) {\n  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));\n}\n\n// ../node_modules/es-toolkit/dist/compat/_internal/getTag.mjs\nfunction getTag(value) {\n  return value == null ? value === void 0 ? \"[object Undefined]\" : \"[object Null]\" : Object.prototype.toString.call(value);\n}\n\n// ../node_modules/es-toolkit/dist/compat/_internal/tags.mjs\nvar regexpTag = \"[object RegExp]\", stringTag = \"[object String]\", numberTag = \"[object Number]\", booleanTag = \"[object Boolean]\", argumentsTag = \"[object Arguments]\", symbolTag = \"[object Symbol]\", dateTag = \"[object Date]\", mapTag = \"[object Map]\", setTag = \"[object Set]\", arrayTag = \"[object Array]\", functionTag = \"[object Function]\", arrayBufferTag = \"[object ArrayBuffer]\", objectTag = \"[object Object]\", errorTag = \"[object Error]\", dataViewTag = \"[object DataView]\", uint8ArrayTag = \"[object Uint8Array]\", uint8ClampedArrayTag = \"[object Uint8ClampedArray]\", uint16ArrayTag = \"[object Uint16Array]\", uint32ArrayTag = \"[object Uint32Array]\", bigUint64ArrayTag = \"[object BigUint64Array]\", int8ArrayTag = \"[object Int8Array]\", int16ArrayTag = \"[object Int16Array]\", int32ArrayTag = \"[object Int32Array]\", bigInt64ArrayTag = \"[object BigInt64Array]\", float32ArrayTag = \"[object Float32Array]\", float64ArrayTag = \"[object Float64Array]\";\n\nexport {\n  isPrimitive,\n  isTypedArray,\n  getSymbols,\n  getTag,\n  regexpTag,\n  stringTag,\n  numberTag,\n  booleanTag,\n  argumentsTag,\n  symbolTag,\n  dateTag,\n  mapTag,\n  setTag,\n  arrayTag,\n  functionTag,\n  arrayBufferTag,\n  objectTag,\n  errorTag,\n  dataViewTag,\n  uint8ArrayTag,\n  uint8ClampedArrayTag,\n  uint16ArrayTag,\n  uint32ArrayTag,\n  bigUint64ArrayTag,\n  int8ArrayTag,\n  int16ArrayTag,\n  int32ArrayTag,\n  bigInt64ArrayTag,\n  float32ArrayTag,\n  float64ArrayTag,\n  isPlainObject\n};\n", "import {\n  argumentsTag,\n  arrayBufferTag,\n  arrayTag,\n  booleanTag,\n  dataViewTag,\n  dateTag,\n  float32ArrayTag,\n  float64ArrayTag,\n  getSymbols,\n  getTag,\n  int16ArrayTag,\n  int32ArrayTag,\n  int8ArrayTag,\n  isPlainObject,\n  isPrimitive,\n  isTypedArray,\n  mapTag,\n  numberTag,\n  objectTag,\n  regexpTag,\n  setTag,\n  stringTag,\n  symbolTag,\n  uint16ArrayTag,\n  uint32ArrayTag,\n  uint8ArrayTag,\n  uint8ClampedArrayTag\n} from \"./chunk-GFLS4VP3.js\";\n\n// ../node_modules/es-toolkit/dist/object/mapValues.mjs\nfunction mapValues(object, getNewValue) {\n  let result = {}, keys = Object.keys(object);\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i], value = object[key];\n    result[key] = getNewValue(value, key, object);\n  }\n  return result;\n}\n\n// ../node_modules/es-toolkit/dist/_internal/isUnsafeProperty.mjs\nfunction isUnsafeProperty(key) {\n  return key === \"__proto__\";\n}\n\n// ../node_modules/es-toolkit/dist/object/mergeWith.mjs\nfunction mergeWith(target, source, merge2) {\n  let sourceKeys = Object.keys(source);\n  for (let i = 0; i < sourceKeys.length; i++) {\n    let key = sourceKeys[i];\n    if (isUnsafeProperty(key))\n      continue;\n    let sourceValue = source[key], targetValue = target[key], merged = merge2(targetValue, sourceValue, key, target, source);\n    merged !== void 0 ? target[key] = merged : Array.isArray(sourceValue) ? Array.isArray(targetValue) ? target[key] = mergeWith(targetValue, sourceValue, merge2) : target[key] = mergeWith([], sourceValue, merge2) : isPlainObject(sourceValue) ? isPlainObject(targetValue) ? target[key] = mergeWith(targetValue, sourceValue, merge2) : target[key] = mergeWith({}, sourceValue, merge2) : (targetValue === void 0 || sourceValue !== void 0) && (target[key] = sourceValue);\n  }\n  return target;\n}\n\n// ../node_modules/es-toolkit/dist/object/pick.mjs\nfunction pick(obj, keys) {\n  let result = {};\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    Object.hasOwn(obj, key) && (result[key] = obj[key]);\n  }\n  return result;\n}\n\n// ../node_modules/es-toolkit/dist/object/pickBy.mjs\nfunction pickBy(obj, shouldPick) {\n  let result = {}, keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i], value = obj[key];\n    shouldPick(value, key) && (result[key] = value);\n  }\n  return result;\n}\n\n// ../node_modules/es-toolkit/dist/object/clone.mjs\nfunction clone(obj) {\n  if (isPrimitive(obj))\n    return obj;\n  if (Array.isArray(obj) || isTypedArray(obj) || obj instanceof ArrayBuffer || typeof SharedArrayBuffer < \"u\" && obj instanceof SharedArrayBuffer)\n    return obj.slice(0);\n  let prototype = Object.getPrototypeOf(obj), Constructor = prototype.constructor;\n  if (obj instanceof Date || obj instanceof Map || obj instanceof Set)\n    return new Constructor(obj);\n  if (obj instanceof RegExp) {\n    let newRegExp = new Constructor(obj);\n    return newRegExp.lastIndex = obj.lastIndex, newRegExp;\n  }\n  if (obj instanceof DataView)\n    return new Constructor(obj.buffer.slice(0));\n  if (obj instanceof Error) {\n    let newError = new Constructor(obj.message);\n    return newError.stack = obj.stack, newError.name = obj.name, newError.cause = obj.cause, newError;\n  }\n  if (typeof File < \"u\" && obj instanceof File)\n    return new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });\n  if (typeof obj == \"object\") {\n    let newObject = Object.create(prototype);\n    return Object.assign(newObject, obj);\n  }\n  return obj;\n}\n\n// ../node_modules/es-toolkit/dist/object/cloneDeepWith.mjs\nfunction cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {\n  let cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);\n  if (cloned !== void 0)\n    return cloned;\n  if (isPrimitive(valueToClone))\n    return valueToClone;\n  if (stack.has(valueToClone))\n    return stack.get(valueToClone);\n  if (Array.isArray(valueToClone)) {\n    let result = new Array(valueToClone.length);\n    stack.set(valueToClone, result);\n    for (let i = 0; i < valueToClone.length; i++)\n      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n    return Object.hasOwn(valueToClone, \"index\") && (result.index = valueToClone.index), Object.hasOwn(valueToClone, \"input\") && (result.input = valueToClone.input), result;\n  }\n  if (valueToClone instanceof Date)\n    return new Date(valueToClone.getTime());\n  if (valueToClone instanceof RegExp) {\n    let result = new RegExp(valueToClone.source, valueToClone.flags);\n    return result.lastIndex = valueToClone.lastIndex, result;\n  }\n  if (valueToClone instanceof Map) {\n    let result = /* @__PURE__ */ new Map();\n    stack.set(valueToClone, result);\n    for (let [key, value] of valueToClone)\n      result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));\n    return result;\n  }\n  if (valueToClone instanceof Set) {\n    let result = /* @__PURE__ */ new Set();\n    stack.set(valueToClone, result);\n    for (let value of valueToClone)\n      result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));\n    return result;\n  }\n  if (typeof Buffer < \"u\" && Buffer.isBuffer(valueToClone))\n    return valueToClone.subarray();\n  if (isTypedArray(valueToClone)) {\n    let result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);\n    stack.set(valueToClone, result);\n    for (let i = 0; i < valueToClone.length; i++)\n      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n    return result;\n  }\n  if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer < \"u\" && valueToClone instanceof SharedArrayBuffer)\n    return valueToClone.slice(0);\n  if (valueToClone instanceof DataView) {\n    let result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);\n    return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;\n  }\n  if (typeof File < \"u\" && valueToClone instanceof File) {\n    let result = new File([valueToClone], valueToClone.name, {\n      type: valueToClone.type\n    });\n    return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;\n  }\n  if (typeof Blob < \"u\" && valueToClone instanceof Blob) {\n    let result = new Blob([valueToClone], { type: valueToClone.type });\n    return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;\n  }\n  if (valueToClone instanceof Error) {\n    let result = new valueToClone.constructor();\n    return stack.set(valueToClone, result), result.message = valueToClone.message, result.name = valueToClone.name, result.stack = valueToClone.stack, result.cause = valueToClone.cause, copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;\n  }\n  if (valueToClone instanceof Boolean) {\n    let result = new Boolean(valueToClone.valueOf());\n    return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;\n  }\n  if (valueToClone instanceof Number) {\n    let result = new Number(valueToClone.valueOf());\n    return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;\n  }\n  if (valueToClone instanceof String) {\n    let result = new String(valueToClone.valueOf());\n    return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;\n  }\n  if (typeof valueToClone == \"object\" && isCloneableObject(valueToClone)) {\n    let result = Object.create(Object.getPrototypeOf(valueToClone));\n    return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;\n  }\n  return valueToClone;\n}\nfunction copyProperties(target, source, objectToClone = target, stack, cloneValue) {\n  let keys = [...Object.keys(source), ...getSymbols(source)];\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i], descriptor = Object.getOwnPropertyDescriptor(target, key);\n    (descriptor == null || descriptor.writable) && (target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue));\n  }\n}\nfunction isCloneableObject(object) {\n  switch (getTag(object)) {\n    case argumentsTag:\n    case arrayTag:\n    case arrayBufferTag:\n    case dataViewTag:\n    case booleanTag:\n    case dateTag:\n    case float32ArrayTag:\n    case float64ArrayTag:\n    case int8ArrayTag:\n    case int16ArrayTag:\n    case int32ArrayTag:\n    case mapTag:\n    case numberTag:\n    case objectTag:\n    case regexpTag:\n    case setTag:\n    case stringTag:\n    case symbolTag:\n    case uint8ArrayTag:\n    case uint8ClampedArrayTag:\n    case uint16ArrayTag:\n    case uint32ArrayTag:\n      return !0;\n    default:\n      return !1;\n  }\n}\n\n// ../node_modules/es-toolkit/dist/object/cloneDeep.mjs\nfunction cloneDeep(obj) {\n  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);\n}\n\n// ../node_modules/es-toolkit/dist/string/words.mjs\nvar CASE_SPLIT_PATTERN = new RegExp(\"\\\\p{Lu}?\\\\p{Ll}+|[0-9]+|\\\\p{Lu}+(?!\\\\p{Ll})|\\\\p{Emoji_Presentation}|\\\\p{Extended_Pictographic}|\\\\p{L}+\", \"gu\");\n\n// ../node_modules/es-toolkit/dist/object/toMerged.mjs\nfunction toMerged(target, source) {\n  return mergeWith(clone(target), source, function mergeRecursively(targetValue, sourceValue) {\n    if (Array.isArray(sourceValue))\n      return Array.isArray(targetValue) ? mergeWith(clone(targetValue), sourceValue, mergeRecursively) : mergeWith([], sourceValue, mergeRecursively);\n    if (isPlainObject(sourceValue))\n      return isPlainObject(targetValue) ? mergeWith(clone(targetValue), sourceValue, mergeRecursively) : mergeWith({}, sourceValue, mergeRecursively);\n  });\n}\n\nexport {\n  cloneDeep,\n  mapValues,\n  mergeWith,\n  pick,\n  pickBy,\n  toMerged\n};\n", "import {\n  mapValues\n} from \"./chunk-AIOS4NGK.js\";\nimport {\n  isPlainObject\n} from \"./chunk-GFLS4VP3.js\";\nimport {\n  __commonJS,\n  __toESM\n} from \"./chunk-A242L54C.js\";\n\n// ../node_modules/jsdoc-type-pratt-parser/dist/index.js\nvar require_dist = __commonJS({\n  \"../node_modules/jsdoc-type-pratt-parser/dist/index.js\"(exports, module) {\n    (function(global, factory) {\n      typeof exports == \"object\" && typeof module < \"u\" ? factory(exports) : typeof define == \"function\" && define.amd ? define([\"exports\"], factory) : (global = typeof globalThis < \"u\" ? globalThis : global || self, factory(global.jtpp = {}));\n    })(exports, (function(exports2) {\n      \"use strict\";\n      function tokenToString(token) {\n        return token.text !== void 0 && token.text !== \"\" ? `'${token.type}' with value '${token.text}'` : `'${token.type}'`;\n      }\n      class NoParsletFoundError extends Error {\n        constructor(token) {\n          super(`No parslet found for token: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, NoParsletFoundError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      }\n      class EarlyEndOfParseError extends Error {\n        constructor(token) {\n          super(`The parsing ended early. The next token was: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      }\n      class UnexpectedTypeError extends Error {\n        constructor(result, message) {\n          let error = `Unexpected type: '${result.type}'.`;\n          message !== void 0 && (error += ` Message: ${message}`), super(error), Object.setPrototypeOf(this, UnexpectedTypeError.prototype);\n        }\n      }\n      function makePunctuationRule(type) {\n        return (text) => text.startsWith(type) ? { type, text: type } : null;\n      }\n      function getQuoted(text) {\n        let position = 0, char, mark = text[0], escaped = !1;\n        if (mark !== \"'\" && mark !== '\"')\n          return null;\n        for (; position < text.length; ) {\n          if (position++, char = text[position], !escaped && char === mark) {\n            position++;\n            break;\n          }\n          escaped = !escaped && char === \"\\\\\";\n        }\n        if (char !== mark)\n          throw new Error(\"Unterminated String\");\n        return text.slice(0, position);\n      }\n      let identifierStartRegex = new RegExp(\"[$_\\\\p{ID_Start}]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\"), identifierContinueRegex = new RegExp(\"[$\\\\-\\\\p{ID_Continue}\\\\u200C\\\\u200D]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n      function getIdentifier(text) {\n        let char = text[0];\n        if (!identifierStartRegex.test(char))\n          return null;\n        let position = 1;\n        do {\n          if (char = text[position], !identifierContinueRegex.test(char))\n            break;\n          position++;\n        } while (position < text.length);\n        return text.slice(0, position);\n      }\n      let numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n      function getNumber(text) {\n        var _a, _b;\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n      }\n      let identifierRule = (text) => {\n        let value = getIdentifier(text);\n        return value == null ? null : {\n          type: \"Identifier\",\n          text: value\n        };\n      };\n      function makeKeyWordRule(type) {\n        return (text) => {\n          if (!text.startsWith(type))\n            return null;\n          let prepends = text[type.length];\n          return prepends !== void 0 && identifierContinueRegex.test(prepends) ? null : {\n            type,\n            text: type\n          };\n        };\n      }\n      let stringValueRule = (text) => {\n        let value = getQuoted(text);\n        return value == null ? null : {\n          type: \"StringValue\",\n          text: value\n        };\n      }, eofRule = (text) => text.length > 0 ? null : {\n        type: \"EOF\",\n        text: \"\"\n      }, numberRule = (text) => {\n        let value = getNumber(text);\n        return value === null ? null : {\n          type: \"Number\",\n          text: value\n        };\n      }, rules = [\n        eofRule,\n        makePunctuationRule(\"=>\"),\n        makePunctuationRule(\"(\"),\n        makePunctuationRule(\")\"),\n        makePunctuationRule(\"{\"),\n        makePunctuationRule(\"}\"),\n        makePunctuationRule(\"[\"),\n        makePunctuationRule(\"]\"),\n        makePunctuationRule(\"|\"),\n        makePunctuationRule(\"&\"),\n        makePunctuationRule(\"<\"),\n        makePunctuationRule(\">\"),\n        makePunctuationRule(\",\"),\n        makePunctuationRule(\";\"),\n        makePunctuationRule(\"*\"),\n        makePunctuationRule(\"?\"),\n        makePunctuationRule(\"!\"),\n        makePunctuationRule(\"=\"),\n        makePunctuationRule(\":\"),\n        makePunctuationRule(\"...\"),\n        makePunctuationRule(\".\"),\n        makePunctuationRule(\"#\"),\n        makePunctuationRule(\"~\"),\n        makePunctuationRule(\"/\"),\n        makePunctuationRule(\"@\"),\n        makeKeyWordRule(\"undefined\"),\n        makeKeyWordRule(\"null\"),\n        makeKeyWordRule(\"function\"),\n        makeKeyWordRule(\"this\"),\n        makeKeyWordRule(\"new\"),\n        makeKeyWordRule(\"module\"),\n        makeKeyWordRule(\"event\"),\n        makeKeyWordRule(\"extends\"),\n        makeKeyWordRule(\"external\"),\n        makeKeyWordRule(\"infer\"),\n        makeKeyWordRule(\"typeof\"),\n        makeKeyWordRule(\"keyof\"),\n        makeKeyWordRule(\"readonly\"),\n        makeKeyWordRule(\"import\"),\n        makeKeyWordRule(\"is\"),\n        makeKeyWordRule(\"in\"),\n        makeKeyWordRule(\"asserts\"),\n        numberRule,\n        identifierRule,\n        stringValueRule\n      ], breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n      class Lexer {\n        static create(text) {\n          let current = this.read(text);\n          text = current.text;\n          let next = this.read(text);\n          return text = next.text, new Lexer(text, void 0, current.token, next.token);\n        }\n        constructor(text, previous, current, next) {\n          this.text = \"\", this.text = text, this.previous = previous, this.current = current, this.next = next;\n        }\n        static read(text, startOfLine = !1) {\n          startOfLine = startOfLine || breakingWhitespaceRegex.test(text), text = text.trim();\n          for (let rule of rules) {\n            let partial = rule(text);\n            if (partial !== null) {\n              let token = Object.assign(Object.assign({}, partial), { startOfLine });\n              return text = text.slice(token.text.length), { text, token };\n            }\n          }\n          throw new Error(\"Unexpected Token \" + text);\n        }\n        advance() {\n          let next = Lexer.read(this.text);\n          return new Lexer(next.text, this.current, this.next, next.token);\n        }\n      }\n      function assertRootResult(result) {\n        if (result === void 0)\n          throw new Error(\"Unexpected undefined\");\n        if (result.type === \"JsdocTypeKeyValue\" || result.type === \"JsdocTypeParameterList\" || result.type === \"JsdocTypeProperty\" || result.type === \"JsdocTypeReadonlyProperty\" || result.type === \"JsdocTypeObjectField\" || result.type === \"JsdocTypeJsdocObjectField\" || result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\" || result.type === \"JsdocTypeTypeParameter\")\n          throw new UnexpectedTypeError(result);\n        return result;\n      }\n      function assertPlainKeyValueOrRootResult(result) {\n        return result.type === \"JsdocTypeKeyValue\" ? assertPlainKeyValueResult(result) : assertRootResult(result);\n      }\n      function assertPlainKeyValueOrNameResult(result) {\n        return result.type === \"JsdocTypeName\" ? result : assertPlainKeyValueResult(result);\n      }\n      function assertPlainKeyValueResult(result) {\n        if (result.type !== \"JsdocTypeKeyValue\")\n          throw new UnexpectedTypeError(result);\n        return result;\n      }\n      function assertNumberOrVariadicNameResult(result) {\n        var _a;\n        if (result.type === \"JsdocTypeVariadic\") {\n          if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === \"JsdocTypeName\")\n            return result;\n          throw new UnexpectedTypeError(result);\n        }\n        if (result.type !== \"JsdocTypeNumber\" && result.type !== \"JsdocTypeName\")\n          throw new UnexpectedTypeError(result);\n        return result;\n      }\n      function assertArrayOrTupleResult(result) {\n        if (result.type === \"JsdocTypeTuple\" || result.type === \"JsdocTypeGeneric\" && result.meta.brackets === \"square\")\n          return result;\n        throw new UnexpectedTypeError(result);\n      }\n      function isSquaredProperty(result) {\n        return result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\";\n      }\n      var Precedence;\n      (function(Precedence2) {\n        Precedence2[Precedence2.ALL = 0] = \"ALL\", Precedence2[Precedence2.PARAMETER_LIST = 1] = \"PARAMETER_LIST\", Precedence2[Precedence2.OBJECT = 2] = \"OBJECT\", Precedence2[Precedence2.KEY_VALUE = 3] = \"KEY_VALUE\", Precedence2[Precedence2.INDEX_BRACKETS = 4] = \"INDEX_BRACKETS\", Precedence2[Precedence2.UNION = 5] = \"UNION\", Precedence2[Precedence2.INTERSECTION = 6] = \"INTERSECTION\", Precedence2[Precedence2.PREFIX = 7] = \"PREFIX\", Precedence2[Precedence2.INFIX = 8] = \"INFIX\", Precedence2[Precedence2.TUPLE = 9] = \"TUPLE\", Precedence2[Precedence2.SYMBOL = 10] = \"SYMBOL\", Precedence2[Precedence2.OPTIONAL = 11] = \"OPTIONAL\", Precedence2[Precedence2.NULLABLE = 12] = \"NULLABLE\", Precedence2[Precedence2.KEY_OF_TYPE_OF = 13] = \"KEY_OF_TYPE_OF\", Precedence2[Precedence2.FUNCTION = 14] = \"FUNCTION\", Precedence2[Precedence2.ARROW = 15] = \"ARROW\", Precedence2[Precedence2.ARRAY_BRACKETS = 16] = \"ARRAY_BRACKETS\", Precedence2[Precedence2.GENERIC = 17] = \"GENERIC\", Precedence2[Precedence2.NAME_PATH = 18] = \"NAME_PATH\", Precedence2[Precedence2.PARENTHESIS = 19] = \"PARENTHESIS\", Precedence2[Precedence2.SPECIAL_TYPES = 20] = \"SPECIAL_TYPES\";\n      })(Precedence || (Precedence = {}));\n      class Parser {\n        constructor(grammar, textOrLexer, baseParser) {\n          this.grammar = grammar, typeof textOrLexer == \"string\" ? this._lexer = Lexer.create(textOrLexer) : this._lexer = textOrLexer, this.baseParser = baseParser;\n        }\n        get lexer() {\n          return this._lexer;\n        }\n        /**\n         * Parses a given string and throws an error if the parse ended before the end of the string.\n         */\n        parse() {\n          let result = this.parseType(Precedence.ALL);\n          if (this.lexer.current.type !== \"EOF\")\n            throw new EarlyEndOfParseError(this.lexer.current);\n          return result;\n        }\n        /**\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n         */\n        parseType(precedence) {\n          return assertRootResult(this.parseIntermediateType(precedence));\n        }\n        /**\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n         * to parse the state in the infix step.\n         */\n        parseIntermediateType(precedence) {\n          let result = this.tryParslets(null, precedence);\n          if (result === null)\n            throw new NoParsletFoundError(this.lexer.current);\n          return this.parseInfixIntermediateType(result, precedence);\n        }\n        /**\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n         * a result.\n         */\n        parseInfixIntermediateType(left, precedence) {\n          let result = this.tryParslets(left, precedence);\n          for (; result !== null; )\n            left = result, result = this.tryParslets(left, precedence);\n          return left;\n        }\n        /**\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n         */\n        tryParslets(left, precedence) {\n          for (let parslet of this.grammar) {\n            let result = parslet(this, precedence, left);\n            if (result !== null)\n              return result;\n          }\n          return null;\n        }\n        /**\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n         * advanced.\n         */\n        consume(types) {\n          return Array.isArray(types) || (types = [types]), types.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;\n        }\n        acceptLexerState(parser) {\n          this._lexer = parser.lexer;\n        }\n      }\n      function isQuestionMarkUnknownType(next) {\n        return next === \"}\" || next === \"EOF\" || next === \"|\" || next === \",\" || next === \")\" || next === \">\";\n      }\n      let nullableParslet = (parser, precedence, left) => {\n        let type = parser.lexer.current.type, next = parser.lexer.next.type;\n        return left == null && type === \"?\" && !isQuestionMarkUnknownType(next) || left != null && type === \"?\" ? (parser.consume(\"?\"), left == null ? {\n          type: \"JsdocTypeNullable\",\n          element: parser.parseType(Precedence.NULLABLE),\n          meta: {\n            position: \"prefix\"\n          }\n        } : {\n          type: \"JsdocTypeNullable\",\n          element: assertRootResult(left),\n          meta: {\n            position: \"suffix\"\n          }\n        }) : null;\n      };\n      function composeParslet(options) {\n        let parslet = (parser, curPrecedence, left) => {\n          let type = parser.lexer.current.type, next = parser.lexer.next.type;\n          if (left === null) {\n            if (\"parsePrefix\" in options && options.accept(type, next))\n              return options.parsePrefix(parser);\n          } else if (\"parseInfix\" in options && options.precedence > curPrecedence && options.accept(type, next))\n            return options.parseInfix(parser, left);\n          return null;\n        };\n        return Object.defineProperty(parslet, \"name\", {\n          value: options.name\n        }), parslet;\n      }\n      let optionalParslet = composeParslet({\n        name: \"optionalParslet\",\n        accept: (type) => type === \"=\",\n        precedence: Precedence.OPTIONAL,\n        parsePrefix: (parser) => (parser.consume(\"=\"), {\n          type: \"JsdocTypeOptional\",\n          element: parser.parseType(Precedence.OPTIONAL),\n          meta: {\n            position: \"prefix\"\n          }\n        }),\n        parseInfix: (parser, left) => (parser.consume(\"=\"), {\n          type: \"JsdocTypeOptional\",\n          element: assertRootResult(left),\n          meta: {\n            position: \"suffix\"\n          }\n        })\n      }), numberParslet = composeParslet({\n        name: \"numberParslet\",\n        accept: (type) => type === \"Number\",\n        parsePrefix: (parser) => {\n          let value = parseFloat(parser.lexer.current.text);\n          return parser.consume(\"Number\"), {\n            type: \"JsdocTypeNumber\",\n            value\n          };\n        }\n      }), parenthesisParslet = composeParslet({\n        name: \"parenthesisParslet\",\n        accept: (type) => type === \"(\",\n        parsePrefix: (parser) => {\n          if (parser.consume(\"(\"), parser.consume(\")\"))\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements: []\n            };\n          let result = parser.parseIntermediateType(Precedence.ALL);\n          if (!parser.consume(\")\"))\n            throw new Error(\"Unterminated parenthesis\");\n          return result.type === \"JsdocTypeParameterList\" ? result : result.type === \"JsdocTypeKeyValue\" ? {\n            type: \"JsdocTypeParameterList\",\n            elements: [result]\n          } : {\n            type: \"JsdocTypeParenthesis\",\n            element: assertRootResult(result)\n          };\n        }\n      }), specialTypesParslet = composeParslet({\n        name: \"specialTypesParslet\",\n        accept: (type, next) => type === \"?\" && isQuestionMarkUnknownType(next) || type === \"null\" || type === \"undefined\" || type === \"*\",\n        parsePrefix: (parser) => {\n          if (parser.consume(\"null\"))\n            return {\n              type: \"JsdocTypeNull\"\n            };\n          if (parser.consume(\"undefined\"))\n            return {\n              type: \"JsdocTypeUndefined\"\n            };\n          if (parser.consume(\"*\"))\n            return {\n              type: \"JsdocTypeAny\"\n            };\n          if (parser.consume(\"?\"))\n            return {\n              type: \"JsdocTypeUnknown\"\n            };\n          throw new Error(\"Unacceptable token: \" + parser.lexer.current.text);\n        }\n      }), notNullableParslet = composeParslet({\n        name: \"notNullableParslet\",\n        accept: (type) => type === \"!\",\n        precedence: Precedence.NULLABLE,\n        parsePrefix: (parser) => (parser.consume(\"!\"), {\n          type: \"JsdocTypeNotNullable\",\n          element: parser.parseType(Precedence.NULLABLE),\n          meta: {\n            position: \"prefix\"\n          }\n        }),\n        parseInfix: (parser, left) => (parser.consume(\"!\"), {\n          type: \"JsdocTypeNotNullable\",\n          element: assertRootResult(left),\n          meta: {\n            position: \"suffix\"\n          }\n        })\n      });\n      function createParameterListParslet({ allowTrailingComma }) {\n        return composeParslet({\n          name: \"parameterListParslet\",\n          accept: (type) => type === \",\",\n          precedence: Precedence.PARAMETER_LIST,\n          parseInfix: (parser, left) => {\n            let elements = [\n              assertPlainKeyValueOrRootResult(left)\n            ];\n            parser.consume(\",\");\n            do\n              try {\n                let next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n                elements.push(assertPlainKeyValueOrRootResult(next));\n              } catch (e) {\n                if (e instanceof NoParsletFoundError)\n                  break;\n                throw e;\n              }\n            while (parser.consume(\",\"));\n            if (elements.length > 0 && elements.slice(0, -1).some((e) => e.type === \"JsdocTypeVariadic\"))\n              throw new Error(\"Only the last parameter may be a rest parameter\");\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements\n            };\n          }\n        });\n      }\n      let genericParslet = composeParslet({\n        name: \"genericParslet\",\n        accept: (type, next) => type === \"<\" || type === \".\" && next === \"<\",\n        precedence: Precedence.GENERIC,\n        parseInfix: (parser, left) => {\n          let dot = parser.consume(\".\");\n          parser.consume(\"<\");\n          let objects = [], infer = !1;\n          if (parser.consume(\"infer\")) {\n            infer = !0;\n            let left2 = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (left2.type !== \"JsdocTypeName\")\n              throw new UnexpectedTypeError(left2, \"A typescript asserts always has to have a name on the left side.\");\n            objects.push(left2);\n          } else\n            do\n              objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n            while (parser.consume(\",\"));\n          if (!parser.consume(\">\"))\n            throw new Error(\"Unterminated generic parameter list\");\n          return Object.assign(Object.assign({ type: \"JsdocTypeGeneric\", left: assertRootResult(left), elements: objects }, infer ? { infer: !0 } : {}), { meta: {\n            brackets: \"angle\",\n            dot\n          } });\n        }\n      }), unionParslet = composeParslet({\n        name: \"unionParslet\",\n        accept: (type) => type === \"|\",\n        precedence: Precedence.UNION,\n        parseInfix: (parser, left) => {\n          parser.consume(\"|\");\n          let elements = [];\n          do\n            elements.push(parser.parseType(Precedence.UNION));\n          while (parser.consume(\"|\"));\n          return {\n            type: \"JsdocTypeUnion\",\n            elements: [assertRootResult(left), ...elements]\n          };\n        }\n      }), baseGrammar = [\n        nullableParslet,\n        optionalParslet,\n        numberParslet,\n        parenthesisParslet,\n        specialTypesParslet,\n        notNullableParslet,\n        createParameterListParslet({\n          allowTrailingComma: !0\n        }),\n        genericParslet,\n        unionParslet,\n        optionalParslet\n      ];\n      function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {\n        return function(parser, precedence, left) {\n          if (left == null || precedence >= Precedence.NAME_PATH)\n            return null;\n          let type = parser.lexer.current.type, next = parser.lexer.next.type;\n          if (!(type === \".\" && next !== \"<\" || type === \"[\" && (allowSquareBracketsOnAnyType || left.type === \"JsdocTypeName\") || allowJsdocNamePaths && (type === \"~\" || type === \"#\")))\n            return null;\n          let pathType, brackets = !1;\n          parser.consume(\".\") ? pathType = \"property\" : parser.consume(\"[\") ? (pathType = \"property-brackets\", brackets = !0) : parser.consume(\"~\") ? pathType = \"inner\" : (parser.consume(\"#\"), pathType = \"instance\");\n          let pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser, parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n          parser.acceptLexerState(pathParser);\n          let right;\n          switch (parsed.type) {\n            case \"JsdocTypeName\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeNumber\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value.toString(10),\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeStringValue\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: parsed.meta.quote\n                }\n              };\n              break;\n            case \"JsdocTypeSpecialNamePath\":\n              if (parsed.specialType === \"event\")\n                right = parsed;\n              else\n                throw new UnexpectedTypeError(parsed, \"Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'\");\n              break;\n            default:\n              throw new UnexpectedTypeError(parsed, \"Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'\");\n          }\n          if (brackets && !parser.consume(\"]\")) {\n            let token = parser.lexer.current;\n            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);\n          }\n          return {\n            type: \"JsdocTypeNamePath\",\n            left: assertRootResult(left),\n            right,\n            pathType\n          };\n        };\n      }\n      function createNameParslet({ allowedAdditionalTokens }) {\n        return composeParslet({\n          name: \"nameParslet\",\n          accept: (type) => type === \"Identifier\" || type === \"this\" || type === \"new\" || allowedAdditionalTokens.includes(type),\n          parsePrefix: (parser) => {\n            let { type, text } = parser.lexer.current;\n            return parser.consume(type), {\n              type: \"JsdocTypeName\",\n              value: text\n            };\n          }\n        });\n      }\n      let stringValueParslet = composeParslet({\n        name: \"stringValueParslet\",\n        accept: (type) => type === \"StringValue\",\n        parsePrefix: (parser) => {\n          let text = parser.lexer.current.text;\n          return parser.consume(\"StringValue\"), {\n            type: \"JsdocTypeStringValue\",\n            value: text.slice(1, -1),\n            meta: {\n              quote: text[0] === \"'\" ? \"single\" : \"double\"\n            }\n          };\n        }\n      });\n      function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {\n        return composeParslet({\n          name: \"specialNamePathParslet\",\n          accept: (type) => allowedTypes.includes(type),\n          parsePrefix: (parser) => {\n            let type = parser.lexer.current.type;\n            if (parser.consume(type), !parser.consume(\":\"))\n              return {\n                type: \"JsdocTypeName\",\n                value: type\n              };\n            let result, token = parser.lexer.current;\n            if (parser.consume(\"StringValue\"))\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value: token.text.slice(1, -1),\n                specialType: type,\n                meta: {\n                  quote: token.text[0] === \"'\" ? \"single\" : \"double\"\n                }\n              };\n            else {\n              let value = \"\", allowed = [\"Identifier\", \"@\", \"/\"];\n              for (; allowed.some((type2) => parser.consume(type2)); )\n                value += token.text, token = parser.lexer.current;\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value,\n                specialType: type,\n                meta: {\n                  quote: void 0\n                }\n              };\n            }\n            let moduleParser = new Parser(pathGrammar2, parser.lexer, parser), moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n            return parser.acceptLexerState(moduleParser), assertRootResult(moduleResult);\n          }\n        });\n      }\n      let basePathGrammar = [\n        createNameParslet({\n          allowedAdditionalTokens: [\"external\", \"module\"]\n        }),\n        stringValueParslet,\n        numberParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: !1,\n          allowJsdocNamePaths: !0,\n          pathGrammar: null\n        })\n      ], pathGrammar = [\n        ...basePathGrammar,\n        createSpecialNamePathParslet({\n          allowedTypes: [\"event\"],\n          pathGrammar: basePathGrammar\n        })\n      ];\n      function getParameters(value) {\n        let parameters;\n        if (value.type === \"JsdocTypeParameterList\")\n          parameters = value.elements;\n        else if (value.type === \"JsdocTypeParenthesis\")\n          parameters = [value.element];\n        else\n          throw new UnexpectedTypeError(value);\n        return parameters.map((p) => assertPlainKeyValueOrRootResult(p));\n      }\n      function getUnnamedParameters(value) {\n        let parameters = getParameters(value);\n        if (parameters.some((p) => p.type === \"JsdocTypeKeyValue\"))\n          throw new Error(\"No parameter should be named\");\n        return parameters;\n      }\n      function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {\n        return composeParslet({\n          name: \"functionParslet\",\n          accept: (type, next) => type === \"function\" || allowNewAsFunctionKeyword && type === \"new\" && next === \"(\",\n          parsePrefix: (parser) => {\n            let newKeyword = parser.consume(\"new\");\n            parser.consume(\"function\");\n            let hasParenthesis = parser.lexer.current.type === \"(\";\n            if (!hasParenthesis) {\n              if (!allowWithoutParenthesis)\n                throw new Error(\"function is missing parameter list\");\n              return {\n                type: \"JsdocTypeName\",\n                value: \"function\"\n              };\n            }\n            let result = {\n              type: \"JsdocTypeFunction\",\n              parameters: [],\n              arrow: !1,\n              constructor: newKeyword,\n              parenthesis: hasParenthesis\n            }, value = parser.parseIntermediateType(Precedence.FUNCTION);\n            if (allowNamedParameters === void 0)\n              result.parameters = getUnnamedParameters(value);\n            else {\n              if (newKeyword && value.type === \"JsdocTypeFunction\" && value.arrow)\n                return result = value, result.constructor = !0, result;\n              result.parameters = getParameters(value);\n              for (let p of result.parameters)\n                if (p.type === \"JsdocTypeKeyValue\" && !allowNamedParameters.includes(p.key))\n                  throw new Error(`only allowed named parameters are ${allowNamedParameters.join(\", \")} but got ${p.type}`);\n            }\n            if (parser.consume(\":\"))\n              result.returnType = parser.parseType(Precedence.PREFIX);\n            else if (!allowNoReturnType)\n              throw new Error(\"function is missing return type\");\n            return result;\n          }\n        });\n      }\n      function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {\n        return composeParslet({\n          name: \"variadicParslet\",\n          accept: (type) => type === \"...\",\n          precedence: Precedence.PREFIX,\n          parsePrefix: (parser) => {\n            parser.consume(\"...\");\n            let brackets = allowEnclosingBrackets && parser.consume(\"[\");\n            try {\n              let element = parser.parseType(Precedence.PREFIX);\n              if (brackets && !parser.consume(\"]\"))\n                throw new Error(\"Unterminated variadic type. Missing ']'\");\n              return {\n                type: \"JsdocTypeVariadic\",\n                element: assertRootResult(element),\n                meta: {\n                  position: \"prefix\",\n                  squareBrackets: brackets\n                }\n              };\n            } catch (e) {\n              if (e instanceof NoParsletFoundError) {\n                if (brackets)\n                  throw new Error(\"Empty square brackets for variadic are not allowed.\");\n                return {\n                  type: \"JsdocTypeVariadic\",\n                  meta: {\n                    position: void 0,\n                    squareBrackets: !1\n                  }\n                };\n              } else\n                throw e;\n            }\n          },\n          parseInfix: allowPostfix ? (parser, left) => (parser.consume(\"...\"), {\n            type: \"JsdocTypeVariadic\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\",\n              squareBrackets: !1\n            }\n          }) : void 0\n        });\n      }\n      let symbolParslet = composeParslet({\n        name: \"symbolParslet\",\n        accept: (type) => type === \"(\",\n        precedence: Precedence.SYMBOL,\n        parseInfix: (parser, left) => {\n          if (left.type !== \"JsdocTypeName\")\n            throw new Error(\"Symbol expects a name on the left side. (Reacting on '(')\");\n          parser.consume(\"(\");\n          let result = {\n            type: \"JsdocTypeSymbol\",\n            value: left.value\n          };\n          if (!parser.consume(\")\")) {\n            let next = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (result.element = assertNumberOrVariadicNameResult(next), !parser.consume(\")\"))\n              throw new Error(\"Symbol does not end after value\");\n          }\n          return result;\n        }\n      }), arrayBracketsParslet = composeParslet({\n        name: \"arrayBracketsParslet\",\n        precedence: Precedence.ARRAY_BRACKETS,\n        accept: (type, next) => type === \"[\" && next === \"]\",\n        parseInfix: (parser, left) => (parser.consume(\"[\"), parser.consume(\"]\"), {\n          type: \"JsdocTypeGeneric\",\n          left: {\n            type: \"JsdocTypeName\",\n            value: \"Array\"\n          },\n          elements: [\n            assertRootResult(left)\n          ],\n          meta: {\n            brackets: \"square\",\n            dot: !1\n          }\n        })\n      });\n      function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {\n        return composeParslet({\n          name: \"objectParslet\",\n          accept: (type) => type === \"{\",\n          parsePrefix: (parser) => {\n            parser.consume(\"{\");\n            let result = {\n              type: \"JsdocTypeObject\",\n              meta: {\n                separator: \"comma\"\n              },\n              elements: []\n            };\n            if (!parser.consume(\"}\")) {\n              let separator, fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);\n              for (; ; ) {\n                fieldParser.acceptLexerState(parser);\n                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n                parser.acceptLexerState(fieldParser), field === void 0 && allowKeyTypes && (field = parser.parseIntermediateType(Precedence.OBJECT));\n                let optional = !1;\n                if (field.type === \"JsdocTypeNullable\" && (optional = !0, field = field.element), field.type === \"JsdocTypeNumber\" || field.type === \"JsdocTypeName\" || field.type === \"JsdocTypeStringValue\") {\n                  let quote2;\n                  field.type === \"JsdocTypeStringValue\" && (quote2 = field.meta.quote), result.elements.push({\n                    type: \"JsdocTypeObjectField\",\n                    key: field.value.toString(),\n                    right: void 0,\n                    optional,\n                    readonly: !1,\n                    meta: {\n                      quote: quote2\n                    }\n                  });\n                } else if (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\")\n                  result.elements.push(field);\n                else\n                  throw new UnexpectedTypeError(field);\n                if (parser.lexer.current.startOfLine)\n                  separator = \"linebreak\", parser.consume(\",\") || parser.consume(\";\");\n                else if (parser.consume(\",\"))\n                  separator = \"comma\";\n                else if (parser.consume(\";\"))\n                  separator = \"semicolon\";\n                else\n                  break;\n                if (parser.lexer.current.type === \"}\")\n                  break;\n              }\n              if (result.meta.separator = separator ?? \"comma\", separator === \"linebreak\" && (result.meta.propertyIndent = \"  \"), !parser.consume(\"}\"))\n                throw new Error(\"Unterminated record type. Missing '}'\");\n            }\n            return result;\n          }\n        });\n      }\n      function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {\n        return composeParslet({\n          name: \"objectFieldParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: (type) => type === \":\",\n          parseInfix: (parser, left) => {\n            var _a;\n            let optional = !1, readonlyProperty = !1;\n            allowOptional && left.type === \"JsdocTypeNullable\" && (optional = !0, left = left.element), allowReadonly && left.type === \"JsdocTypeReadonlyProperty\" && (readonlyProperty = !0, left = left.element);\n            let parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n            if (parentParser.acceptLexerState(parser), left.type === \"JsdocTypeNumber\" || left.type === \"JsdocTypeName\" || left.type === \"JsdocTypeStringValue\" || isSquaredProperty(left)) {\n              if (isSquaredProperty(left) && !allowSquaredProperties)\n                throw new UnexpectedTypeError(left);\n              parentParser.consume(\":\");\n              let quote2;\n              left.type === \"JsdocTypeStringValue\" && (quote2 = left.meta.quote);\n              let right = parentParser.parseType(Precedence.KEY_VALUE);\n              return parser.acceptLexerState(parentParser), {\n                type: \"JsdocTypeObjectField\",\n                key: isSquaredProperty(left) ? left : left.value.toString(),\n                right,\n                optional,\n                readonly: readonlyProperty,\n                meta: {\n                  quote: quote2\n                }\n              };\n            } else {\n              if (!allowKeyTypes)\n                throw new UnexpectedTypeError(left);\n              parentParser.consume(\":\");\n              let right = parentParser.parseType(Precedence.KEY_VALUE);\n              return parser.acceptLexerState(parentParser), {\n                type: \"JsdocTypeJsdocObjectField\",\n                left: assertRootResult(left),\n                right\n              };\n            }\n          }\n        });\n      }\n      function createKeyValueParslet({ allowOptional, allowVariadic }) {\n        return composeParslet({\n          name: \"keyValueParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: (type) => type === \":\",\n          parseInfix: (parser, left) => {\n            let optional = !1, variadic = !1;\n            if (allowOptional && left.type === \"JsdocTypeNullable\" && (optional = !0, left = left.element), allowVariadic && left.type === \"JsdocTypeVariadic\" && left.element !== void 0 && (variadic = !0, left = left.element), left.type !== \"JsdocTypeName\")\n              throw new UnexpectedTypeError(left);\n            parser.consume(\":\");\n            let right = parser.parseType(Precedence.KEY_VALUE);\n            return {\n              type: \"JsdocTypeKeyValue\",\n              key: left.value,\n              right,\n              optional,\n              variadic\n            };\n          }\n        });\n      }\n      let jsdocBaseGrammar = [\n        ...baseGrammar,\n        createFunctionParslet({\n          allowWithoutParenthesis: !0,\n          allowNamedParameters: [\"this\", \"new\"],\n          allowNoReturnType: !0,\n          allowNewAsFunctionKeyword: !1\n        }),\n        stringValueParslet,\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\", \"external\", \"event\"],\n          pathGrammar\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: !0,\n          allowPostfix: !0\n        }),\n        createNameParslet({\n          allowedAdditionalTokens: [\"keyof\"]\n        }),\n        symbolParslet,\n        arrayBracketsParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: !1,\n          allowJsdocNamePaths: !0,\n          pathGrammar\n        })\n      ], jsdocGrammar = [\n        ...jsdocBaseGrammar,\n        createObjectParslet({\n          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n          // we leave out the object type deliberately\n          objectFieldGrammar: [\n            createNameParslet({\n              allowedAdditionalTokens: [\"typeof\", \"module\", \"in\"]\n            }),\n            createObjectFieldParslet({\n              allowSquaredProperties: !1,\n              allowKeyTypes: !0,\n              allowOptional: !1,\n              allowReadonly: !1\n            }),\n            ...jsdocBaseGrammar\n          ],\n          allowKeyTypes: !0\n        }),\n        createKeyValueParslet({\n          allowOptional: !0,\n          allowVariadic: !0\n        })\n      ], typeOfParslet = composeParslet({\n        name: \"typeOfParslet\",\n        accept: (type) => type === \"typeof\",\n        parsePrefix: (parser) => (parser.consume(\"typeof\"), {\n          type: \"JsdocTypeTypeof\",\n          element: parser.parseType(Precedence.KEY_OF_TYPE_OF)\n        })\n      }), objectFieldGrammar$1 = [\n        createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n          allowSquaredProperties: !1,\n          allowKeyTypes: !1,\n          allowOptional: !1,\n          allowReadonly: !1\n        })\n      ], closureGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n          allowKeyTypes: !1,\n          objectFieldGrammar: objectFieldGrammar$1\n        }),\n        createNameParslet({\n          allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n        }),\n        typeOfParslet,\n        createFunctionParslet({\n          allowWithoutParenthesis: !1,\n          allowNamedParameters: [\"this\", \"new\"],\n          allowNoReturnType: !0,\n          allowNewAsFunctionKeyword: !1\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: !1,\n          allowPostfix: !1\n        }),\n        // additional name parslet is needed for some special cases\n        createNameParslet({\n          allowedAdditionalTokens: [\"keyof\"]\n        }),\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\"],\n          pathGrammar\n        }),\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: !1,\n          allowJsdocNamePaths: !0,\n          pathGrammar\n        }),\n        createKeyValueParslet({\n          allowOptional: !1,\n          allowVariadic: !1\n        }),\n        symbolParslet\n      ], assertsParslet = composeParslet({\n        name: \"assertsParslet\",\n        accept: (type) => type === \"asserts\",\n        parsePrefix: (parser) => {\n          parser.consume(\"asserts\");\n          let left = parser.parseIntermediateType(Precedence.SYMBOL);\n          if (left.type !== \"JsdocTypeName\")\n            throw new UnexpectedTypeError(left, \"A typescript asserts always has to have a name on the left side.\");\n          return parser.consume(\"is\") ? {\n            type: \"JsdocTypeAsserts\",\n            left,\n            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n          } : {\n            type: \"JsdocTypeAssertsPlain\",\n            element: left\n          };\n        }\n      });\n      function createTupleParslet({ allowQuestionMark }) {\n        return composeParslet({\n          name: \"tupleParslet\",\n          accept: (type) => type === \"[\",\n          parsePrefix: (parser) => {\n            parser.consume(\"[\");\n            let result = {\n              type: \"JsdocTypeTuple\",\n              elements: []\n            };\n            if (parser.consume(\"]\"))\n              return result;\n            let typeList = parser.parseIntermediateType(Precedence.ALL);\n            if (typeList.type === \"JsdocTypeParameterList\" ? typeList.elements[0].type === \"JsdocTypeKeyValue\" ? result.elements = typeList.elements.map(assertPlainKeyValueResult) : result.elements = typeList.elements.map(assertRootResult) : typeList.type === \"JsdocTypeKeyValue\" ? result.elements = [assertPlainKeyValueResult(typeList)] : result.elements = [assertRootResult(typeList)], !parser.consume(\"]\"))\n              throw new Error(\"Unterminated '['\");\n            if (result.elements.some((e) => e.type === \"JsdocTypeUnknown\"))\n              throw new Error(\"Question mark in tuple not allowed\");\n            return result;\n          }\n        });\n      }\n      let keyOfParslet = composeParslet({\n        name: \"keyOfParslet\",\n        accept: (type) => type === \"keyof\",\n        parsePrefix: (parser) => (parser.consume(\"keyof\"), {\n          type: \"JsdocTypeKeyof\",\n          element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n        })\n      }), importParslet = composeParslet({\n        name: \"importParslet\",\n        accept: (type) => type === \"import\",\n        parsePrefix: (parser) => {\n          if (parser.consume(\"import\"), !parser.consume(\"(\"))\n            throw new Error(\"Missing parenthesis after import keyword\");\n          let path = parser.parseType(Precedence.PREFIX);\n          if (path.type !== \"JsdocTypeStringValue\")\n            throw new Error(\"Only string values are allowed as paths for imports\");\n          if (!parser.consume(\")\"))\n            throw new Error(\"Missing closing parenthesis after import keyword\");\n          return {\n            type: \"JsdocTypeImport\",\n            element: path\n          };\n        }\n      }), readonlyPropertyParslet = composeParslet({\n        name: \"readonlyPropertyParslet\",\n        accept: (type) => type === \"readonly\",\n        parsePrefix: (parser) => (parser.consume(\"readonly\"), {\n          type: \"JsdocTypeReadonlyProperty\",\n          element: parser.parseIntermediateType(Precedence.KEY_VALUE)\n        })\n      }), arrowFunctionParslet = composeParslet({\n        name: \"arrowFunctionParslet\",\n        precedence: Precedence.ARROW,\n        accept: (type) => type === \"=>\",\n        parseInfix: (parser, left) => (parser.consume(\"=>\"), {\n          type: \"JsdocTypeFunction\",\n          parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n          arrow: !0,\n          constructor: !1,\n          parenthesis: !0,\n          returnType: parser.parseType(Precedence.OBJECT)\n        })\n      }), genericArrowFunctionParslet = composeParslet({\n        name: \"genericArrowFunctionParslet\",\n        accept: (type) => type === \"<\",\n        parsePrefix: (parser) => {\n          let typeParameters = [];\n          parser.consume(\"<\");\n          do {\n            let defaultValue, name = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (name.type === \"JsdocTypeOptional\" && (name = name.element, defaultValue = parser.parseType(Precedence.SYMBOL)), name.type !== \"JsdocTypeName\")\n              throw new UnexpectedTypeError(name);\n            let constraint;\n            parser.consume(\"extends\") && (constraint = parser.parseType(Precedence.SYMBOL), constraint.type === \"JsdocTypeOptional\" && (constraint = constraint.element, defaultValue = parser.parseType(Precedence.SYMBOL)));\n            let typeParameter = {\n              type: \"JsdocTypeTypeParameter\",\n              name\n            };\n            if (constraint !== void 0 && (typeParameter.constraint = constraint), defaultValue !== void 0 && (typeParameter.defaultValue = defaultValue), typeParameters.push(typeParameter), parser.consume(\">\"))\n              break;\n          } while (parser.consume(\",\"));\n          let functionBase = parser.parseIntermediateType(Precedence.SYMBOL);\n          return functionBase.typeParameters = typeParameters, functionBase;\n        }\n      }), intersectionParslet = composeParslet({\n        name: \"intersectionParslet\",\n        accept: (type) => type === \"&\",\n        precedence: Precedence.INTERSECTION,\n        parseInfix: (parser, left) => {\n          parser.consume(\"&\");\n          let elements = [];\n          do\n            elements.push(parser.parseType(Precedence.INTERSECTION));\n          while (parser.consume(\"&\"));\n          return {\n            type: \"JsdocTypeIntersection\",\n            elements: [assertRootResult(left), ...elements]\n          };\n        }\n      }), predicateParslet = composeParslet({\n        name: \"predicateParslet\",\n        precedence: Precedence.INFIX,\n        accept: (type) => type === \"is\",\n        parseInfix: (parser, left) => {\n          if (left.type !== \"JsdocTypeName\")\n            throw new UnexpectedTypeError(left, \"A typescript predicate always has to have a name on the left side.\");\n          return parser.consume(\"is\"), {\n            type: \"JsdocTypePredicate\",\n            left,\n            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n          };\n        }\n      }), objectSquaredPropertyParslet = composeParslet({\n        name: \"objectSquareBracketPropertyParslet\",\n        accept: (type) => type === \"[\",\n        parsePrefix: (parser) => {\n          if (parser.baseParser === void 0)\n            throw new Error(\"Only allowed inside object grammar\");\n          parser.consume(\"[\");\n          let key = parser.lexer.current.text;\n          parser.consume(\"Identifier\");\n          let result;\n          if (parser.consume(\":\")) {\n            let parentParser = parser.baseParser;\n            parentParser.acceptLexerState(parser), result = {\n              type: \"JsdocTypeIndexSignature\",\n              key,\n              right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n            }, parser.acceptLexerState(parentParser);\n          } else if (parser.consume(\"in\")) {\n            let parentParser = parser.baseParser;\n            parentParser.acceptLexerState(parser), result = {\n              type: \"JsdocTypeMappedType\",\n              key,\n              right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n            }, parser.acceptLexerState(parentParser);\n          } else\n            throw new Error(\"Missing ':' or 'in' inside square bracketed property.\");\n          if (!parser.consume(\"]\"))\n            throw new Error(\"Unterminated square brackets\");\n          return result;\n        }\n      }), readonlyArrayParslet = composeParslet({\n        name: \"readonlyArrayParslet\",\n        accept: (type) => type === \"readonly\",\n        parsePrefix: (parser) => (parser.consume(\"readonly\"), {\n          type: \"JsdocTypeReadonlyArray\",\n          element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))\n        })\n      }), conditionalParslet = composeParslet({\n        name: \"conditionalParslet\",\n        precedence: Precedence.INFIX,\n        accept: (type) => type === \"extends\",\n        parseInfix: (parser, left) => {\n          parser.consume(\"extends\");\n          let extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element, trueType = parser.parseType(Precedence.INFIX);\n          return parser.consume(\":\"), {\n            type: \"JsdocTypeConditional\",\n            checksType: assertRootResult(left),\n            extendsType,\n            trueType,\n            falseType: parser.parseType(Precedence.INFIX)\n          };\n        }\n      }), objectFieldGrammar = [\n        readonlyPropertyParslet,\n        createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n          allowSquaredProperties: !0,\n          allowKeyTypes: !1,\n          allowOptional: !0,\n          allowReadonly: !0\n        }),\n        objectSquaredPropertyParslet\n      ], typescriptGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n          allowKeyTypes: !1,\n          objectFieldGrammar\n        }),\n        readonlyArrayParslet,\n        typeOfParslet,\n        keyOfParslet,\n        importParslet,\n        stringValueParslet,\n        createFunctionParslet({\n          allowWithoutParenthesis: !0,\n          allowNoReturnType: !1,\n          allowNamedParameters: [\"this\", \"new\", \"args\"],\n          allowNewAsFunctionKeyword: !0\n        }),\n        createTupleParslet({\n          allowQuestionMark: !1\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: !1,\n          allowPostfix: !1\n        }),\n        assertsParslet,\n        conditionalParslet,\n        createNameParslet({\n          allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n        }),\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\"],\n          pathGrammar\n        }),\n        arrayBracketsParslet,\n        arrowFunctionParslet,\n        genericArrowFunctionParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: !0,\n          allowJsdocNamePaths: !1,\n          pathGrammar\n        }),\n        intersectionParslet,\n        predicateParslet,\n        createKeyValueParslet({\n          allowVariadic: !0,\n          allowOptional: !0\n        })\n      ];\n      function parse3(expression, mode) {\n        switch (mode) {\n          case \"closure\":\n            return new Parser(closureGrammar, expression).parse();\n          case \"jsdoc\":\n            return new Parser(jsdocGrammar, expression).parse();\n          case \"typescript\":\n            return new Parser(typescriptGrammar, expression).parse();\n        }\n      }\n      function tryParse(expression, modes = [\"typescript\", \"closure\", \"jsdoc\"]) {\n        let error;\n        for (let mode of modes)\n          try {\n            return parse3(expression, mode);\n          } catch (e) {\n            error = e;\n          }\n        throw error;\n      }\n      function transform(rules2, parseResult) {\n        let rule = rules2[parseResult.type];\n        if (rule === void 0)\n          throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n        return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));\n      }\n      function notAvailableTransform(parseResult) {\n        throw new Error(\"This transform is not available. Are you trying the correct parsing mode?\");\n      }\n      function extractSpecialParams(source) {\n        let result = {\n          params: []\n        };\n        for (let param of source.parameters)\n          param.type === \"JsdocTypeKeyValue\" ? param.key === \"this\" ? result.this = param.right : param.key === \"new\" ? result.new = param.right : result.params.push(param) : result.params.push(param);\n        return result;\n      }\n      function applyPosition(position, target, value) {\n        return position === \"prefix\" ? value + target : target + value;\n      }\n      function quote(value, quote2) {\n        switch (quote2) {\n          case \"double\":\n            return `\"${value}\"`;\n          case \"single\":\n            return `'${value}'`;\n          case void 0:\n            return value;\n        }\n      }\n      function stringifyRules2() {\n        return {\n          JsdocTypeParenthesis: (result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : \"\"})`,\n          JsdocTypeKeyof: (result, transform2) => `keyof ${transform2(result.element)}`,\n          JsdocTypeFunction: (result, transform2) => {\n            var _a;\n            if (result.arrow) {\n              if (result.returnType === void 0)\n                throw new Error(\"Arrow function needs a return type.\");\n              let stringified = `${result.typeParameters !== void 0 ? `<${(_a = result.typeParameters.map(transform2).join(\", \")) !== null && _a !== void 0 ? _a : \"\"}>` : \"\"}(${result.parameters.map(transform2).join(\", \")}) => ${transform2(result.returnType)}`;\n              return result.constructor && (stringified = \"new \" + stringified), stringified;\n            } else {\n              let stringified = result.constructor ? \"new\" : \"function\";\n              return result.parenthesis && (stringified += `(${result.parameters.map(transform2).join(\", \")})`, result.returnType !== void 0 && (stringified += `: ${transform2(result.returnType)}`)), stringified;\n            }\n          },\n          JsdocTypeName: (result) => result.value,\n          JsdocTypeTuple: (result, transform2) => `[${result.elements.map(transform2).join(\", \")}]`,\n          JsdocTypeVariadic: (result, transform2) => result.meta.position === void 0 ? \"...\" : applyPosition(result.meta.position, transform2(result.element), \"...\"),\n          JsdocTypeNamePath: (result, transform2) => {\n            let left = transform2(result.left), right = transform2(result.right);\n            switch (result.pathType) {\n              case \"inner\":\n                return `${left}~${right}`;\n              case \"instance\":\n                return `${left}#${right}`;\n              case \"property\":\n                return `${left}.${right}`;\n              case \"property-brackets\":\n                return `${left}[${right}]`;\n            }\n          },\n          JsdocTypeStringValue: (result) => quote(result.value, result.meta.quote),\n          JsdocTypeAny: () => \"*\",\n          JsdocTypeGeneric: (result, transform2) => {\n            if (result.meta.brackets === \"square\") {\n              let element = result.elements[0], transformed = transform2(element);\n              return element.type === \"JsdocTypeUnion\" || element.type === \"JsdocTypeIntersection\" ? `(${transformed})[]` : `${transformed}[]`;\n            } else\n              return `${transform2(result.left)}${result.meta.dot ? \".\" : \"\"}<${result.infer === !0 ? \"infer \" : \"\"}${result.elements.map(transform2).join(\", \")}>`;\n          },\n          JsdocTypeImport: (result, transform2) => `import(${transform2(result.element)})`,\n          JsdocTypeObjectField: (result, transform2) => {\n            let text = \"\";\n            return result.readonly && (text += \"readonly \"), typeof result.key == \"string\" ? text += quote(result.key, result.meta.quote) : text += transform2(result.key), result.optional && (text += \"?\"), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;\n          },\n          JsdocTypeJsdocObjectField: (result, transform2) => `${transform2(result.left)}: ${transform2(result.right)}`,\n          JsdocTypeKeyValue: (result, transform2) => {\n            let text = result.key;\n            return result.optional && (text += \"?\"), result.variadic && (text = \"...\" + text), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;\n          },\n          JsdocTypeSpecialNamePath: (result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n          JsdocTypeNotNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"!\"),\n          JsdocTypeNull: () => \"null\",\n          JsdocTypeNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"?\"),\n          JsdocTypeNumber: (result) => result.value.toString(),\n          JsdocTypeObject: (result, transform2) => {\n            var _a, _b;\n            return `{${(result.meta.separator === \"linebreak\" && result.elements.length > 1 ? `\n` + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : \"\") : \"\") + result.elements.map(transform2).join(result.meta.separator === \"comma\" ? \", \" : result.meta.separator === \"linebreak\" ? `\n` + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : \"\") : \"; \") + (result.meta.separator === \"linebreak\" && result.elements.length > 1 ? `\n` : \"\")}}`;\n          },\n          JsdocTypeOptional: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"=\"),\n          JsdocTypeSymbol: (result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : \"\"})`,\n          JsdocTypeTypeof: (result, transform2) => `typeof ${transform2(result.element)}`,\n          JsdocTypeUndefined: () => \"undefined\",\n          JsdocTypeUnion: (result, transform2) => result.elements.map(transform2).join(\" | \"),\n          JsdocTypeUnknown: () => \"?\",\n          JsdocTypeIntersection: (result, transform2) => result.elements.map(transform2).join(\" & \"),\n          JsdocTypeProperty: (result) => quote(result.value, result.meta.quote),\n          JsdocTypePredicate: (result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`,\n          JsdocTypeIndexSignature: (result, transform2) => `[${result.key}: ${transform2(result.right)}]`,\n          JsdocTypeMappedType: (result, transform2) => `[${result.key} in ${transform2(result.right)}]`,\n          JsdocTypeAsserts: (result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`,\n          JsdocTypeReadonlyArray: (result, transform2) => `readonly ${transform2(result.element)}`,\n          JsdocTypeAssertsPlain: (result, transform2) => `asserts ${transform2(result.element)}`,\n          JsdocTypeConditional: (result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`,\n          JsdocTypeTypeParameter: (result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : \"\"}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : \"\"}`\n        };\n      }\n      let storedStringifyRules = stringifyRules2();\n      function stringify2(result) {\n        return transform(storedStringifyRules, result);\n      }\n      let reservedWords = [\n        \"null\",\n        \"true\",\n        \"false\",\n        \"break\",\n        \"case\",\n        \"catch\",\n        \"class\",\n        \"const\",\n        \"continue\",\n        \"debugger\",\n        \"default\",\n        \"delete\",\n        \"do\",\n        \"else\",\n        \"export\",\n        \"extends\",\n        \"finally\",\n        \"for\",\n        \"function\",\n        \"if\",\n        \"import\",\n        \"in\",\n        \"instanceof\",\n        \"new\",\n        \"return\",\n        \"super\",\n        \"switch\",\n        \"this\",\n        \"throw\",\n        \"try\",\n        \"typeof\",\n        \"var\",\n        \"void\",\n        \"while\",\n        \"with\",\n        \"yield\"\n      ];\n      function makeName(value) {\n        let result = {\n          type: \"NameExpression\",\n          name: value\n        };\n        return reservedWords.includes(value) && (result.reservedWord = !0), result;\n      }\n      let catharsisTransformRules = {\n        JsdocTypeOptional: (result, transform2) => {\n          let transformed = transform2(result.element);\n          return transformed.optional = !0, transformed;\n        },\n        JsdocTypeNullable: (result, transform2) => {\n          let transformed = transform2(result.element);\n          return transformed.nullable = !0, transformed;\n        },\n        JsdocTypeNotNullable: (result, transform2) => {\n          let transformed = transform2(result.element);\n          return transformed.nullable = !1, transformed;\n        },\n        JsdocTypeVariadic: (result, transform2) => {\n          if (result.element === void 0)\n            throw new Error(\"dots without value are not allowed in catharsis mode\");\n          let transformed = transform2(result.element);\n          return transformed.repeatable = !0, transformed;\n        },\n        JsdocTypeAny: () => ({\n          type: \"AllLiteral\"\n        }),\n        JsdocTypeNull: () => ({\n          type: \"NullLiteral\"\n        }),\n        JsdocTypeStringValue: (result) => makeName(quote(result.value, result.meta.quote)),\n        JsdocTypeUndefined: () => ({\n          type: \"UndefinedLiteral\"\n        }),\n        JsdocTypeUnknown: () => ({\n          type: \"UnknownLiteral\"\n        }),\n        JsdocTypeFunction: (result, transform2) => {\n          let params = extractSpecialParams(result), transformed = {\n            type: \"FunctionType\",\n            params: params.params.map(transform2)\n          };\n          return params.this !== void 0 && (transformed.this = transform2(params.this)), params.new !== void 0 && (transformed.new = transform2(params.new)), result.returnType !== void 0 && (transformed.result = transform2(result.returnType)), transformed;\n        },\n        JsdocTypeGeneric: (result, transform2) => ({\n          type: \"TypeApplication\",\n          applications: result.elements.map((o) => transform2(o)),\n          expression: transform2(result.left)\n        }),\n        JsdocTypeSpecialNamePath: (result) => makeName(result.specialType + \":\" + quote(result.value, result.meta.quote)),\n        JsdocTypeName: (result) => result.value !== \"function\" ? makeName(result.value) : {\n          type: \"FunctionType\",\n          params: []\n        },\n        JsdocTypeNumber: (result) => makeName(result.value.toString()),\n        JsdocTypeObject: (result, transform2) => {\n          let transformed = {\n            type: \"RecordType\",\n            fields: []\n          };\n          for (let field of result.elements)\n            field.type !== \"JsdocTypeObjectField\" && field.type !== \"JsdocTypeJsdocObjectField\" ? transformed.fields.push({\n              type: \"FieldType\",\n              key: transform2(field),\n              value: void 0\n            }) : transformed.fields.push(transform2(field));\n          return transformed;\n        },\n        JsdocTypeObjectField: (result, transform2) => {\n          if (typeof result.key != \"string\")\n            throw new Error(\"Index signatures and mapped types are not supported\");\n          return {\n            type: \"FieldType\",\n            key: makeName(quote(result.key, result.meta.quote)),\n            value: result.right === void 0 ? void 0 : transform2(result.right)\n          };\n        },\n        JsdocTypeJsdocObjectField: (result, transform2) => ({\n          type: \"FieldType\",\n          key: transform2(result.left),\n          value: transform2(result.right)\n        }),\n        JsdocTypeUnion: (result, transform2) => ({\n          type: \"TypeUnion\",\n          elements: result.elements.map((e) => transform2(e))\n        }),\n        JsdocTypeKeyValue: (result, transform2) => ({\n          type: \"FieldType\",\n          key: makeName(result.key),\n          value: result.right === void 0 ? void 0 : transform2(result.right)\n        }),\n        JsdocTypeNamePath: (result, transform2) => {\n          let leftResult = transform2(result.left), rightValue;\n          result.right.type === \"JsdocTypeSpecialNamePath\" ? rightValue = transform2(result.right).name : rightValue = quote(result.right.value, result.right.meta.quote);\n          let joiner = result.pathType === \"inner\" ? \"~\" : result.pathType === \"instance\" ? \"#\" : \".\";\n          return makeName(`${leftResult.name}${joiner}${rightValue}`);\n        },\n        JsdocTypeSymbol: (result) => {\n          let value = \"\", element = result.element, trailingDots = !1;\n          return element?.type === \"JsdocTypeVariadic\" && (element.meta.position === \"prefix\" ? value = \"...\" : trailingDots = !0, element = element.element), element?.type === \"JsdocTypeName\" ? value += element.value : element?.type === \"JsdocTypeNumber\" && (value += element.value.toString()), trailingDots && (value += \"...\"), makeName(`${result.value}(${value})`);\n        },\n        JsdocTypeParenthesis: (result, transform2) => transform2(assertRootResult(result.element)),\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeImport: notAvailableTransform,\n        JsdocTypeKeyof: notAvailableTransform,\n        JsdocTypeTuple: notAvailableTransform,\n        JsdocTypeTypeof: notAvailableTransform,\n        JsdocTypeIntersection: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function catharsisTransform(result) {\n        return transform(catharsisTransformRules, result);\n      }\n      function getQuoteStyle(quote2) {\n        switch (quote2) {\n          case void 0:\n            return \"none\";\n          case \"single\":\n            return \"single\";\n          case \"double\":\n            return \"double\";\n        }\n      }\n      function getMemberType(type) {\n        switch (type) {\n          case \"inner\":\n            return \"INNER_MEMBER\";\n          case \"instance\":\n            return \"INSTANCE_MEMBER\";\n          case \"property\":\n            return \"MEMBER\";\n          case \"property-brackets\":\n            return \"MEMBER\";\n        }\n      }\n      function nestResults(type, results) {\n        return results.length === 2 ? {\n          type,\n          left: results[0],\n          right: results[1]\n        } : {\n          type,\n          left: results[0],\n          right: nestResults(type, results.slice(1))\n        };\n      }\n      let jtpRules = {\n        JsdocTypeOptional: (result, transform2) => ({\n          type: \"OPTIONAL\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_EQUAL_SIGN\" : \"SUFFIX_EQUALS_SIGN\"\n          }\n        }),\n        JsdocTypeNullable: (result, transform2) => ({\n          type: \"NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_QUESTION_MARK\" : \"SUFFIX_QUESTION_MARK\"\n          }\n        }),\n        JsdocTypeNotNullable: (result, transform2) => ({\n          type: \"NOT_NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_BANG\" : \"SUFFIX_BANG\"\n          }\n        }),\n        JsdocTypeVariadic: (result, transform2) => {\n          let transformed = {\n            type: \"VARIADIC\",\n            meta: {\n              syntax: result.meta.position === \"prefix\" ? \"PREFIX_DOTS\" : result.meta.position === \"suffix\" ? \"SUFFIX_DOTS\" : \"ONLY_DOTS\"\n            }\n          };\n          return result.element !== void 0 && (transformed.value = transform2(result.element)), transformed;\n        },\n        JsdocTypeName: (result) => ({\n          type: \"NAME\",\n          name: result.value\n        }),\n        JsdocTypeTypeof: (result, transform2) => ({\n          type: \"TYPE_QUERY\",\n          name: transform2(result.element)\n        }),\n        JsdocTypeTuple: (result, transform2) => ({\n          type: \"TUPLE\",\n          entries: result.elements.map(transform2)\n        }),\n        JsdocTypeKeyof: (result, transform2) => ({\n          type: \"KEY_QUERY\",\n          value: transform2(result.element)\n        }),\n        JsdocTypeImport: (result) => ({\n          type: \"IMPORT\",\n          path: {\n            type: \"STRING_VALUE\",\n            quoteStyle: getQuoteStyle(result.element.meta.quote),\n            string: result.element.value\n          }\n        }),\n        JsdocTypeUndefined: () => ({\n          type: \"NAME\",\n          name: \"undefined\"\n        }),\n        JsdocTypeAny: () => ({\n          type: \"ANY\"\n        }),\n        JsdocTypeFunction: (result, transform2) => {\n          let specialParams = extractSpecialParams(result), transformed = {\n            type: result.arrow ? \"ARROW\" : \"FUNCTION\",\n            params: specialParams.params.map((param) => {\n              if (param.type === \"JsdocTypeKeyValue\") {\n                if (param.right === void 0)\n                  throw new Error(\"Function parameter without ':' is not expected to be 'KEY_VALUE'\");\n                return {\n                  type: \"NAMED_PARAMETER\",\n                  name: param.key,\n                  typeName: transform2(param.right)\n                };\n              } else\n                return transform2(param);\n            }),\n            new: null,\n            returns: null\n          };\n          return specialParams.this !== void 0 ? transformed.this = transform2(specialParams.this) : result.arrow || (transformed.this = null), specialParams.new !== void 0 && (transformed.new = transform2(specialParams.new)), result.returnType !== void 0 && (transformed.returns = transform2(result.returnType)), transformed;\n        },\n        JsdocTypeGeneric: (result, transform2) => {\n          let transformed = {\n            type: \"GENERIC\",\n            subject: transform2(result.left),\n            objects: result.elements.map(transform2),\n            meta: {\n              syntax: result.meta.brackets === \"square\" ? \"SQUARE_BRACKET\" : result.meta.dot ? \"ANGLE_BRACKET_WITH_DOT\" : \"ANGLE_BRACKET\"\n            }\n          };\n          return result.meta.brackets === \"square\" && result.elements[0].type === \"JsdocTypeFunction\" && !result.elements[0].parenthesis && (transformed.objects[0] = {\n            type: \"NAME\",\n            name: \"function\"\n          }), transformed;\n        },\n        JsdocTypeObjectField: (result, transform2) => {\n          if (typeof result.key != \"string\")\n            throw new Error(\"Index signatures and mapped types are not supported\");\n          if (result.right === void 0)\n            return {\n              type: \"RECORD_ENTRY\",\n              key: result.key,\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              value: null,\n              readonly: !1\n            };\n          let right = transform2(result.right);\n          return result.optional && (right = {\n            type: \"OPTIONAL\",\n            value: right,\n            meta: {\n              syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n            }\n          }), {\n            type: \"RECORD_ENTRY\",\n            key: result.key.toString(),\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            value: right,\n            readonly: !1\n          };\n        },\n        JsdocTypeJsdocObjectField: () => {\n          throw new Error(\"Keys may not be typed in jsdoctypeparser.\");\n        },\n        JsdocTypeKeyValue: (result, transform2) => {\n          if (result.right === void 0)\n            return {\n              type: \"RECORD_ENTRY\",\n              key: result.key,\n              quoteStyle: \"none\",\n              value: null,\n              readonly: !1\n            };\n          let right = transform2(result.right);\n          return result.optional && (right = {\n            type: \"OPTIONAL\",\n            value: right,\n            meta: {\n              syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n            }\n          }), {\n            type: \"RECORD_ENTRY\",\n            key: result.key,\n            quoteStyle: \"none\",\n            value: right,\n            readonly: !1\n          };\n        },\n        JsdocTypeObject: (result, transform2) => {\n          let entries = [];\n          for (let field of result.elements)\n            (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\") && entries.push(transform2(field));\n          return {\n            type: \"RECORD\",\n            entries\n          };\n        },\n        JsdocTypeSpecialNamePath: (result) => {\n          if (result.specialType !== \"module\")\n            throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n          return {\n            type: \"MODULE\",\n            value: {\n              type: \"FILE_PATH\",\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              path: result.value\n            }\n          };\n        },\n        JsdocTypeNamePath: (result, transform2) => {\n          let hasEventPrefix = !1, name, quoteStyle;\n          result.right.type === \"JsdocTypeSpecialNamePath\" && result.right.specialType === \"event\" ? (hasEventPrefix = !0, name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote)) : (name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote));\n          let transformed = {\n            type: getMemberType(result.pathType),\n            owner: transform2(result.left),\n            name,\n            quoteStyle,\n            hasEventPrefix\n          };\n          if (transformed.owner.type === \"MODULE\") {\n            let tModule = transformed.owner;\n            return transformed.owner = transformed.owner.value, tModule.value = transformed, tModule;\n          } else\n            return transformed;\n        },\n        JsdocTypeUnion: (result, transform2) => nestResults(\"UNION\", result.elements.map(transform2)),\n        JsdocTypeParenthesis: (result, transform2) => ({\n          type: \"PARENTHESIS\",\n          value: transform2(assertRootResult(result.element))\n        }),\n        JsdocTypeNull: () => ({\n          type: \"NAME\",\n          name: \"null\"\n        }),\n        JsdocTypeUnknown: () => ({\n          type: \"UNKNOWN\"\n        }),\n        JsdocTypeStringValue: (result) => ({\n          type: \"STRING_VALUE\",\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          string: result.value\n        }),\n        JsdocTypeIntersection: (result, transform2) => nestResults(\"INTERSECTION\", result.elements.map(transform2)),\n        JsdocTypeNumber: (result) => ({\n          type: \"NUMBER_VALUE\",\n          number: result.value.toString()\n        }),\n        JsdocTypeSymbol: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function jtpTransform(result) {\n        return transform(jtpRules, result);\n      }\n      function identityTransformRules() {\n        return {\n          JsdocTypeIntersection: (result, transform2) => ({\n            type: \"JsdocTypeIntersection\",\n            elements: result.elements.map(transform2)\n          }),\n          JsdocTypeGeneric: (result, transform2) => ({\n            type: \"JsdocTypeGeneric\",\n            left: transform2(result.left),\n            elements: result.elements.map(transform2),\n            meta: {\n              dot: result.meta.dot,\n              brackets: result.meta.brackets\n            }\n          }),\n          JsdocTypeNullable: (result) => result,\n          JsdocTypeUnion: (result, transform2) => ({\n            type: \"JsdocTypeUnion\",\n            elements: result.elements.map(transform2)\n          }),\n          JsdocTypeUnknown: (result) => result,\n          JsdocTypeUndefined: (result) => result,\n          JsdocTypeTypeof: (result, transform2) => ({\n            type: \"JsdocTypeTypeof\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeSymbol: (result, transform2) => {\n            let transformed = {\n              type: \"JsdocTypeSymbol\",\n              value: result.value\n            };\n            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;\n          },\n          JsdocTypeOptional: (result, transform2) => ({\n            type: \"JsdocTypeOptional\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }),\n          JsdocTypeObject: (result, transform2) => ({\n            type: \"JsdocTypeObject\",\n            meta: {\n              separator: \"comma\"\n            },\n            elements: result.elements.map(transform2)\n          }),\n          JsdocTypeNumber: (result) => result,\n          JsdocTypeNull: (result) => result,\n          JsdocTypeNotNullable: (result, transform2) => ({\n            type: \"JsdocTypeNotNullable\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }),\n          JsdocTypeSpecialNamePath: (result) => result,\n          JsdocTypeObjectField: (result, transform2) => ({\n            type: \"JsdocTypeObjectField\",\n            key: result.key,\n            right: result.right === void 0 ? void 0 : transform2(result.right),\n            optional: result.optional,\n            readonly: result.readonly,\n            meta: result.meta\n          }),\n          JsdocTypeJsdocObjectField: (result, transform2) => ({\n            type: \"JsdocTypeJsdocObjectField\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }),\n          JsdocTypeKeyValue: (result, transform2) => ({\n            type: \"JsdocTypeKeyValue\",\n            key: result.key,\n            right: result.right === void 0 ? void 0 : transform2(result.right),\n            optional: result.optional,\n            variadic: result.variadic\n          }),\n          JsdocTypeImport: (result, transform2) => ({\n            type: \"JsdocTypeImport\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeAny: (result) => result,\n          JsdocTypeStringValue: (result) => result,\n          JsdocTypeNamePath: (result) => result,\n          JsdocTypeVariadic: (result, transform2) => {\n            let transformed = {\n              type: \"JsdocTypeVariadic\",\n              meta: {\n                position: result.meta.position,\n                squareBrackets: result.meta.squareBrackets\n              }\n            };\n            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;\n          },\n          JsdocTypeTuple: (result, transform2) => ({\n            type: \"JsdocTypeTuple\",\n            elements: result.elements.map(transform2)\n          }),\n          JsdocTypeName: (result) => result,\n          JsdocTypeFunction: (result, transform2) => {\n            let transformed = {\n              type: \"JsdocTypeFunction\",\n              arrow: result.arrow,\n              parameters: result.parameters.map(transform2),\n              constructor: result.constructor,\n              parenthesis: result.parenthesis\n            };\n            return result.returnType !== void 0 && (transformed.returnType = transform2(result.returnType)), transformed;\n          },\n          JsdocTypeKeyof: (result, transform2) => ({\n            type: \"JsdocTypeKeyof\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeParenthesis: (result, transform2) => ({\n            type: \"JsdocTypeParenthesis\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeProperty: (result) => result,\n          JsdocTypePredicate: (result, transform2) => ({\n            type: \"JsdocTypePredicate\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }),\n          JsdocTypeIndexSignature: (result, transform2) => ({\n            type: \"JsdocTypeIndexSignature\",\n            key: result.key,\n            right: transform2(result.right)\n          }),\n          JsdocTypeMappedType: (result, transform2) => ({\n            type: \"JsdocTypeMappedType\",\n            key: result.key,\n            right: transform2(result.right)\n          }),\n          JsdocTypeAsserts: (result, transform2) => ({\n            type: \"JsdocTypeAsserts\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }),\n          JsdocTypeReadonlyArray: (result, transform2) => ({\n            type: \"JsdocTypeReadonlyArray\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeAssertsPlain: (result, transform2) => ({\n            type: \"JsdocTypeAssertsPlain\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeConditional: (result, transform2) => ({\n            type: \"JsdocTypeConditional\",\n            checksType: transform2(result.checksType),\n            extendsType: transform2(result.extendsType),\n            trueType: transform2(result.trueType),\n            falseType: transform2(result.falseType)\n          }),\n          JsdocTypeTypeParameter: (result, transform2) => ({\n            type: \"JsdocTypeTypeParameter\",\n            name: transform2(result.name),\n            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,\n            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0\n          })\n        };\n      }\n      let visitorKeys = {\n        JsdocTypeAny: [],\n        JsdocTypeFunction: [\"parameters\", \"returnType\"],\n        JsdocTypeGeneric: [\"left\", \"elements\"],\n        JsdocTypeImport: [],\n        JsdocTypeIndexSignature: [\"right\"],\n        JsdocTypeIntersection: [\"elements\"],\n        JsdocTypeKeyof: [\"element\"],\n        JsdocTypeKeyValue: [\"right\"],\n        JsdocTypeMappedType: [\"right\"],\n        JsdocTypeName: [],\n        JsdocTypeNamePath: [\"left\", \"right\"],\n        JsdocTypeNotNullable: [\"element\"],\n        JsdocTypeNull: [],\n        JsdocTypeNullable: [\"element\"],\n        JsdocTypeNumber: [],\n        JsdocTypeObject: [\"elements\"],\n        JsdocTypeObjectField: [\"right\"],\n        JsdocTypeJsdocObjectField: [\"left\", \"right\"],\n        JsdocTypeOptional: [\"element\"],\n        JsdocTypeParenthesis: [\"element\"],\n        JsdocTypeSpecialNamePath: [],\n        JsdocTypeStringValue: [],\n        JsdocTypeSymbol: [\"element\"],\n        JsdocTypeTuple: [\"elements\"],\n        JsdocTypeTypeof: [\"element\"],\n        JsdocTypeUndefined: [],\n        JsdocTypeUnion: [\"elements\"],\n        JsdocTypeUnknown: [],\n        JsdocTypeVariadic: [\"element\"],\n        JsdocTypeProperty: [],\n        JsdocTypePredicate: [\"left\", \"right\"],\n        JsdocTypeAsserts: [\"left\", \"right\"],\n        JsdocTypeReadonlyArray: [\"element\"],\n        JsdocTypeAssertsPlain: [\"element\"],\n        JsdocTypeConditional: [\"checksType\", \"extendsType\", \"trueType\", \"falseType\"],\n        JsdocTypeTypeParameter: [\"name\", \"constraint\", \"defaultValue\"]\n      };\n      function _traverse(node, parentNode, property, onEnter, onLeave) {\n        onEnter?.(node, parentNode, property);\n        let keysToVisit = visitorKeys[node.type];\n        for (let key of keysToVisit) {\n          let value = node[key];\n          if (value !== void 0)\n            if (Array.isArray(value))\n              for (let element of value)\n                _traverse(element, node, key, onEnter, onLeave);\n            else\n              _traverse(value, node, key, onEnter, onLeave);\n        }\n        onLeave?.(node, parentNode, property);\n      }\n      function traverse(node, onEnter, onLeave) {\n        _traverse(node, void 0, void 0, onEnter, onLeave);\n      }\n      exports2.catharsisTransform = catharsisTransform, exports2.identityTransformRules = identityTransformRules, exports2.jtpTransform = jtpTransform, exports2.parse = parse3, exports2.stringify = stringify2, exports2.stringifyRules = stringifyRules2, exports2.transform = transform, exports2.traverse = traverse, exports2.tryParse = tryParse, exports2.visitorKeys = visitorKeys;\n    }));\n  }\n});\n\n// src/docs-tools/argTypes/convert/flow/convert.ts\nimport { UnknownArgTypesError } from \"storybook/internal/preview-errors\";\nvar isLiteral = (type) => type.name === \"literal\", toEnumOption = (element) => element.value.replace(/['|\"]/g, \"\"), convertSig = (type) => {\n  switch (type.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      let values = {};\n      return type.signature.properties.forEach((prop) => {\n        values[prop.key] = convert(prop.value);\n      }), {\n        name: \"object\",\n        value: values\n      };\n    default:\n      throw new UnknownArgTypesError({ type, language: \"Flow\" });\n  }\n}, convert = (type) => {\n  let { name, raw } = type, base = {};\n  switch (typeof raw < \"u\" && (base.raw = raw), type.name) {\n    case \"literal\":\n      return { ...base, name: \"other\", value: type.value };\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      return { ...base, name };\n    case \"Array\":\n      return { ...base, name: \"array\", value: type.elements.map(convert) };\n    case \"signature\":\n      return { ...base, ...convertSig(type) };\n    case \"union\":\n      return type.elements?.every(isLiteral) ? { ...base, name: \"enum\", value: type.elements?.map(toEnumOption) } : { ...base, name, value: type.elements?.map(convert) };\n    case \"intersection\":\n      return { ...base, name, value: type.elements?.map(convert) };\n    default:\n      return { ...base, name: \"other\", value: name };\n  }\n};\n\n// src/docs-tools/argTypes/convert/utils.ts\nvar QUOTE_REGEX = /^['\"]|['\"]$/g, trimQuotes = (str2) => str2.replace(QUOTE_REGEX, \"\"), includesQuotes = (str2) => QUOTE_REGEX.test(str2), parseLiteral = (str2) => {\n  let trimmedValue = trimQuotes(str2);\n  return includesQuotes(str2) || Number.isNaN(Number(trimmedValue)) ? trimmedValue : Number(trimmedValue);\n};\n\n// src/docs-tools/argTypes/convert/proptypes/convert.ts\nvar SIGNATURE_REGEXP = /^\\(.*\\) => /, convert2 = (type) => {\n  let { name, raw, computed, value } = type, base = {};\n  switch (typeof raw < \"u\" && (base.raw = raw), name) {\n    case \"enum\": {\n      let values2 = computed ? value : value.map((v) => parseLiteral(v.value));\n      return { ...base, name, value: values2 };\n    }\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n      return { ...base, name };\n    case \"func\":\n      return { ...base, name: \"function\" };\n    case \"bool\":\n    case \"boolean\":\n      return { ...base, name: \"boolean\" };\n    case \"arrayOf\":\n    case \"array\":\n      return { ...base, name: \"array\", value: value && convert2(value) };\n    case \"object\":\n      return { ...base, name };\n    case \"objectOf\":\n      return { ...base, name, value: convert2(value) };\n    case \"shape\":\n    case \"exact\":\n      let values = mapValues(value, (field) => convert2(field));\n      return { ...base, name: \"object\", value: values };\n    case \"union\":\n      return { ...base, name: \"union\", value: value.map((v) => convert2(v)) };\n    case \"instanceOf\":\n    case \"element\":\n    case \"elementType\":\n    default: {\n      if (name?.indexOf(\"|\") > 0)\n        try {\n          let literalValues = name.split(\"|\").map((v) => JSON.parse(v));\n          return { ...base, name: \"enum\", value: literalValues };\n        } catch {\n        }\n      let otherVal = value ? `${name}(${value})` : name, otherName = SIGNATURE_REGEXP.test(name) ? \"function\" : \"other\";\n      return { ...base, name: otherName, value: otherVal };\n    }\n  }\n};\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nimport { UnknownArgTypesError as UnknownArgTypesError2 } from \"storybook/internal/preview-errors\";\nvar convertSig2 = (type) => {\n  switch (type.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      let values = {};\n      return type.signature.properties.forEach((prop) => {\n        values[prop.key] = convert3(prop.value);\n      }), {\n        name: \"object\",\n        value: values\n      };\n    default:\n      throw new UnknownArgTypesError2({ type, language: \"Typescript\" });\n  }\n}, convert3 = (type) => {\n  let { name, raw } = type, base = {};\n  switch (typeof raw < \"u\" && (base.raw = raw), type.name) {\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      return { ...base, name };\n    case \"Array\":\n      return { ...base, name: \"array\", value: type.elements.map(convert3) };\n    case \"signature\":\n      return { ...base, ...convertSig2(type) };\n    case \"union\":\n      let result;\n      return type.elements?.every((element) => element.name === \"literal\") ? result = {\n        ...base,\n        name: \"enum\",\n        // @ts-expect-error fix types\n        value: type.elements?.map((v) => parseLiteral(v.value))\n      } : result = { ...base, name, value: type.elements?.map(convert3) }, result;\n    case \"intersection\":\n      return { ...base, name, value: type.elements?.map(convert3) };\n    default:\n      return { ...base, name: \"other\", value: name };\n  }\n};\n\n// src/docs-tools/argTypes/convert/index.ts\nvar convert4 = (docgenInfo) => {\n  let { type, tsType, flowType } = docgenInfo;\n  try {\n    if (type != null)\n      return convert2(type);\n    if (tsType != null)\n      return convert3(tsType);\n    if (flowType != null)\n      return convert(flowType);\n  } catch (err) {\n    console.error(err);\n  }\n  return null;\n};\n\n// src/docs-tools/argTypes/docgen/types.ts\nvar TypeSystem = /* @__PURE__ */ ((TypeSystem2) => (TypeSystem2.JAVASCRIPT = \"JavaScript\", TypeSystem2.FLOW = \"Flow\", TypeSystem2.TYPESCRIPT = \"TypeScript\", TypeSystem2.UNKNOWN = \"Unknown\", TypeSystem2))(TypeSystem || {});\n\n// src/docs-tools/argTypes/docgen/utils/defaultValue.ts\nvar BLACKLIST = [\"null\", \"undefined\"];\nfunction isDefaultValueBlacklisted(value) {\n  return BLACKLIST.some((x) => x === value);\n}\n\n// src/docs-tools/argTypes/docgen/utils/string.ts\nvar str = (obj) => {\n  if (!obj)\n    return \"\";\n  if (typeof obj == \"string\")\n    return obj;\n  throw new Error(`Description: expected string, got: ${JSON.stringify(obj)}`);\n};\n\n// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts\nfunction hasDocgen(component) {\n  return !!component.__docgenInfo;\n}\nfunction isValidDocgenSection(docgenSection) {\n  return docgenSection != null && Object.keys(docgenSection).length > 0;\n}\nfunction getDocgenSection(component, section) {\n  return hasDocgen(component) ? component.__docgenInfo[section] : null;\n}\nfunction getDocgenDescription(component) {\n  return hasDocgen(component) ? str(component.__docgenInfo.description) : \"\";\n}\n\n// ../node_modules/comment-parser/es6/primitives.js\nvar Markers;\n(function(Markers2) {\n  Markers2.start = \"/**\", Markers2.nostart = \"/***\", Markers2.delim = \"*\", Markers2.end = \"*/\";\n})(Markers = Markers || (Markers = {}));\n\n// ../node_modules/comment-parser/es6/util.js\nfunction isSpace(source) {\n  return /^\\s+$/.test(source);\n}\nfunction splitCR(source) {\n  let matches = source.match(/\\r+$/);\n  return matches == null ? [\"\", source] : [source.slice(-matches[0].length), source.slice(0, -matches[0].length)];\n}\nfunction splitSpace(source) {\n  let matches = source.match(/^\\s+/);\n  return matches == null ? [\"\", source] : [source.slice(0, matches[0].length), source.slice(matches[0].length)];\n}\nfunction splitLines(source) {\n  return source.split(/\\n/);\n}\nfunction seedSpec(spec = {}) {\n  return Object.assign({ tag: \"\", name: \"\", type: \"\", optional: !1, description: \"\", problems: [], source: [] }, spec);\n}\nfunction seedTokens(tokens = {}) {\n  return Object.assign({ start: \"\", delimiter: \"\", postDelimiter: \"\", tag: \"\", postTag: \"\", name: \"\", postName: \"\", type: \"\", postType: \"\", description: \"\", end: \"\", lineEnd: \"\" }, tokens);\n}\n\n// ../node_modules/comment-parser/es6/parser/block-parser.js\nvar reTag = /^@\\S+/;\nfunction getParser({ fence = \"```\" } = {}) {\n  let fencer = getFencer(fence), toggleFence = (source, isFenced) => fencer(source) ? !isFenced : isFenced;\n  return function(source) {\n    let sections = [[]], isFenced = !1;\n    for (let line of source)\n      reTag.test(line.tokens.description) && !isFenced ? sections.push([line]) : sections[sections.length - 1].push(line), isFenced = toggleFence(line.tokens.description, isFenced);\n    return sections;\n  };\n}\nfunction getFencer(fence) {\n  return typeof fence == \"string\" ? (source) => source.split(fence).length % 2 === 0 : fence;\n}\n\n// ../node_modules/comment-parser/es6/parser/source-parser.js\nfunction getParser2({ startLine = 0, markers = Markers } = {}) {\n  let block = null, num = startLine;\n  return function(source) {\n    let rest = source, tokens = seedTokens();\n    if ([tokens.lineEnd, rest] = splitCR(rest), [tokens.start, rest] = splitSpace(rest), block === null && rest.startsWith(markers.start) && !rest.startsWith(markers.nostart) && (block = [], tokens.delimiter = rest.slice(0, markers.start.length), rest = rest.slice(markers.start.length), [tokens.postDelimiter, rest] = splitSpace(rest)), block === null)\n      return num++, null;\n    let isClosed = rest.trimRight().endsWith(markers.end);\n    if (tokens.delimiter === \"\" && rest.startsWith(markers.delim) && !rest.startsWith(markers.end) && (tokens.delimiter = markers.delim, rest = rest.slice(markers.delim.length), [tokens.postDelimiter, rest] = splitSpace(rest)), isClosed) {\n      let trimmed = rest.trimRight();\n      tokens.end = rest.slice(trimmed.length - markers.end.length), rest = trimmed.slice(0, -markers.end.length);\n    }\n    if (tokens.description = rest, block.push({ number: num, source, tokens }), num++, isClosed) {\n      let result = block.slice();\n      return block = null, result;\n    }\n    return null;\n  };\n}\n\n// ../node_modules/comment-parser/es6/parser/spec-parser.js\nfunction getParser3({ tokenizers }) {\n  return function(source) {\n    var _a;\n    let spec = seedSpec({ source });\n    for (let tokenize of tokenizers)\n      if (spec = tokenize(spec), !((_a = spec.problems[spec.problems.length - 1]) === null || _a === void 0) && _a.critical)\n        break;\n    return spec;\n  };\n}\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js\nfunction tagTokenizer() {\n  return (spec) => {\n    let { tokens } = spec.source[0], match = tokens.description.match(/\\s*(@(\\S+))(\\s*)/);\n    return match === null ? (spec.problems.push({\n      code: \"spec:tag:prefix\",\n      message: 'tag should start with \"@\" symbol',\n      line: spec.source[0].number,\n      critical: !0\n    }), spec) : (tokens.tag = match[1], tokens.postTag = match[3], tokens.description = tokens.description.slice(match[0].length), spec.tag = match[2], spec);\n  };\n}\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/type.js\nfunction typeTokenizer(spacing = \"compact\") {\n  let join2 = getJoiner(spacing);\n  return (spec) => {\n    let curlies = 0, lines = [];\n    for (let [i, { tokens }] of spec.source.entries()) {\n      let type = \"\";\n      if (i === 0 && tokens.description[0] !== \"{\")\n        return spec;\n      for (let ch of tokens.description)\n        if (ch === \"{\" && curlies++, ch === \"}\" && curlies--, type += ch, curlies === 0)\n          break;\n      if (lines.push([tokens, type]), curlies === 0)\n        break;\n    }\n    if (curlies !== 0)\n      return spec.problems.push({\n        code: \"spec:type:unpaired-curlies\",\n        message: \"unpaired curlies\",\n        line: spec.source[0].number,\n        critical: !0\n      }), spec;\n    let parts = [], offset = lines[0][0].postDelimiter.length;\n    for (let [i, [tokens, type]] of lines.entries())\n      tokens.type = type, i > 0 && (tokens.type = tokens.postDelimiter.slice(offset) + type, tokens.postDelimiter = tokens.postDelimiter.slice(0, offset)), [tokens.postType, tokens.description] = splitSpace(tokens.description.slice(type.length)), parts.push(tokens.type);\n    return parts[0] = parts[0].slice(1), parts[parts.length - 1] = parts[parts.length - 1].slice(0, -1), spec.type = join2(parts), spec;\n  };\n}\nvar trim = (x) => x.trim();\nfunction getJoiner(spacing) {\n  return spacing === \"compact\" ? (t) => t.map(trim).join(\"\") : spacing === \"preserve\" ? (t) => t.join(`\n`) : spacing;\n}\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/name.js\nvar isQuoted = (s) => s && s.startsWith('\"') && s.endsWith('\"');\nfunction nameTokenizer() {\n  let typeEnd = (num, { tokens }, i) => tokens.type === \"\" ? num : i;\n  return (spec) => {\n    let { tokens } = spec.source[spec.source.reduce(typeEnd, 0)], source = tokens.description.trimLeft(), quotedGroups = source.split('\"');\n    if (quotedGroups.length > 1 && quotedGroups[0] === \"\" && quotedGroups.length % 2 === 1)\n      return spec.name = quotedGroups[1], tokens.name = `\"${quotedGroups[1]}\"`, [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length)), spec;\n    let brackets = 0, name = \"\", optional = !1, defaultValue;\n    for (let ch of source) {\n      if (brackets === 0 && isSpace(ch))\n        break;\n      ch === \"[\" && brackets++, ch === \"]\" && brackets--, name += ch;\n    }\n    if (brackets !== 0)\n      return spec.problems.push({\n        code: \"spec:name:unpaired-brackets\",\n        message: \"unpaired brackets\",\n        line: spec.source[0].number,\n        critical: !0\n      }), spec;\n    let nameToken = name;\n    if (name[0] === \"[\" && name[name.length - 1] === \"]\") {\n      optional = !0, name = name.slice(1, -1);\n      let parts = name.split(\"=\");\n      if (name = parts[0].trim(), parts[1] !== void 0 && (defaultValue = parts.slice(1).join(\"=\").trim()), name === \"\")\n        return spec.problems.push({\n          code: \"spec:name:empty-name\",\n          message: \"empty name\",\n          line: spec.source[0].number,\n          critical: !0\n        }), spec;\n      if (defaultValue === \"\")\n        return spec.problems.push({\n          code: \"spec:name:empty-default\",\n          message: \"empty default value\",\n          line: spec.source[0].number,\n          critical: !0\n        }), spec;\n      if (!isQuoted(defaultValue) && /=(?!>)/.test(defaultValue))\n        return spec.problems.push({\n          code: \"spec:name:invalid-default\",\n          message: \"invalid default value syntax\",\n          line: spec.source[0].number,\n          critical: !0\n        }), spec;\n    }\n    return spec.optional = optional, spec.name = name, tokens.name = nameToken, defaultValue !== void 0 && (spec.default = defaultValue), [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length)), spec;\n  };\n}\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/description.js\nfunction descriptionTokenizer(spacing = \"compact\", markers = Markers) {\n  let join2 = getJoiner2(spacing);\n  return (spec) => (spec.description = join2(spec.source, markers), spec);\n}\nfunction getJoiner2(spacing) {\n  return spacing === \"compact\" ? compactJoiner : spacing === \"preserve\" ? preserveJoiner : spacing;\n}\nfunction compactJoiner(lines, markers = Markers) {\n  return lines.map(({ tokens: { description } }) => description.trim()).filter((description) => description !== \"\").join(\" \");\n}\nvar lineNo = (num, { tokens }, i) => tokens.type === \"\" ? num : i, getDescription = ({ tokens }) => (tokens.delimiter === \"\" ? tokens.start : tokens.postDelimiter.slice(1)) + tokens.description;\nfunction preserveJoiner(lines, markers = Markers) {\n  if (lines.length === 0)\n    return \"\";\n  lines[0].tokens.description === \"\" && lines[0].tokens.delimiter === markers.start && (lines = lines.slice(1));\n  let lastLine = lines[lines.length - 1];\n  return lastLine !== void 0 && lastLine.tokens.description === \"\" && lastLine.tokens.end.endsWith(markers.end) && (lines = lines.slice(0, -1)), lines = lines.slice(lines.reduce(lineNo, 0)), lines.map(getDescription).join(`\n`);\n}\n\n// ../node_modules/comment-parser/es6/parser/index.js\nfunction getParser4({ startLine = 0, fence = \"```\", spacing = \"compact\", markers = Markers, tokenizers = [\n  tagTokenizer(),\n  typeTokenizer(spacing),\n  nameTokenizer(),\n  descriptionTokenizer(spacing)\n] } = {}) {\n  if (startLine < 0 || startLine % 1 > 0)\n    throw new Error(\"Invalid startLine\");\n  let parseSource = getParser2({ startLine, markers }), parseBlock = getParser({ fence }), parseSpec = getParser3({ tokenizers }), joinDescription = getJoiner2(spacing);\n  return function(source) {\n    let blocks = [];\n    for (let line of splitLines(source)) {\n      let lines = parseSource(line);\n      if (lines === null)\n        continue;\n      let sections = parseBlock(lines), specs = sections.slice(1).map(parseSpec);\n      blocks.push({\n        description: joinDescription(sections[0], markers),\n        tags: specs,\n        source: lines,\n        problems: specs.reduce((acc, spec) => acc.concat(spec.problems), [])\n      });\n    }\n    return blocks;\n  };\n}\n\n// ../node_modules/comment-parser/es6/stringifier/index.js\nfunction join(tokens) {\n  return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;\n}\nfunction getStringifier() {\n  return (block) => block.source.map(({ tokens }) => join(tokens)).join(`\n`);\n}\n\n// ../node_modules/comment-parser/es6/stringifier/inspect.js\nvar zeroWidth = {\n  line: 0,\n  start: 0,\n  delimiter: 0,\n  postDelimiter: 0,\n  tag: 0,\n  postTag: 0,\n  name: 0,\n  postName: 0,\n  type: 0,\n  postType: 0,\n  description: 0,\n  end: 0,\n  lineEnd: 0\n};\nvar fields = Object.keys(zeroWidth);\n\n// ../node_modules/comment-parser/es6/index.js\nfunction parse(source, options = {}) {\n  return getParser4(options)(source);\n}\nvar stringify = getStringifier();\n\n// src/docs-tools/argTypes/jsdocParser.ts\nvar import_jsdoc_type_pratt_parser = __toESM(require_dist(), 1);\nfunction containsJsDoc(value) {\n  return value != null && value.includes(\"@\");\n}\nfunction parse2(content) {\n  let normalisedContent = `/**\n` + (content ?? \"\").split(`\n`).map((line) => ` * ${line}`).join(`\n`) + `\n*/`, ast = parse(normalisedContent, {\n    spacing: \"preserve\"\n  });\n  if (!ast || ast.length === 0)\n    throw new Error(\"Cannot parse JSDoc tags.\");\n  return ast[0];\n}\nvar DEFAULT_OPTIONS = {\n  tags: [\"param\", \"arg\", \"argument\", \"returns\", \"ignore\", \"deprecated\"]\n}, parseJsDoc = (value, options = DEFAULT_OPTIONS) => {\n  if (!containsJsDoc(value))\n    return {\n      includesJsDoc: !1,\n      ignore: !1\n    };\n  let jsDocAst = parse2(value), extractedTags = extractJsDocTags(jsDocAst, options.tags);\n  return extractedTags.ignore ? {\n    includesJsDoc: !0,\n    ignore: !0\n  } : {\n    includesJsDoc: !0,\n    ignore: !1,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: jsDocAst.description.trim(),\n    extractedTags\n  };\n};\nfunction extractJsDocTags(ast, tags) {\n  let extractedTags = {\n    params: null,\n    deprecated: null,\n    returns: null,\n    ignore: !1\n  };\n  for (let tagSpec of ast.tags)\n    if (!(tags !== void 0 && !tags.includes(tagSpec.tag)))\n      if (tagSpec.tag === \"ignore\") {\n        extractedTags.ignore = !0;\n        break;\n      } else\n        switch (tagSpec.tag) {\n          // arg & argument are aliases for param.\n          case \"param\":\n          case \"arg\":\n          case \"argument\": {\n            let paramTag = extractParam(tagSpec);\n            paramTag != null && (extractedTags.params == null && (extractedTags.params = []), extractedTags.params.push(paramTag));\n            break;\n          }\n          case \"deprecated\": {\n            let deprecatedTag = extractDeprecated(tagSpec);\n            deprecatedTag != null && (extractedTags.deprecated = deprecatedTag);\n            break;\n          }\n          case \"returns\": {\n            let returnsTag = extractReturns(tagSpec);\n            returnsTag != null && (extractedTags.returns = returnsTag);\n            break;\n          }\n          default:\n            break;\n        }\n  return extractedTags;\n}\nfunction normaliseParamName(name) {\n  return name.replace(/[\\.-]$/, \"\");\n}\nfunction extractParam(tag) {\n  if (!tag.name || tag.name === \"-\")\n    return null;\n  let type = extractType(tag.type);\n  return {\n    name: tag.name,\n    type,\n    description: normaliseDescription(tag.description),\n    getPrettyName: () => normaliseParamName(tag.name),\n    getTypeName: () => type ? extractTypeName(type) : null\n  };\n}\nfunction extractDeprecated(tag) {\n  return tag.name ? joinNameAndDescription(tag.name, tag.description) : null;\n}\nfunction joinNameAndDescription(name, desc) {\n  let joined = name === \"\" ? desc : `${name} ${desc}`;\n  return normaliseDescription(joined);\n}\nfunction normaliseDescription(text) {\n  let normalised = text.replace(/^- /g, \"\").trim();\n  return normalised === \"\" ? null : normalised;\n}\nfunction extractReturns(tag) {\n  let type = extractType(tag.type);\n  return type ? {\n    type,\n    description: joinNameAndDescription(tag.name, tag.description),\n    getTypeName: () => extractTypeName(type)\n  } : null;\n}\nvar jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)(), originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;\njsdocStringifyRules.JsdocTypeAny = () => \"any\";\njsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;\njsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join(\"|\");\nfunction extractType(typeString) {\n  try {\n    return (0, import_jsdoc_type_pratt_parser.parse)(typeString, \"typescript\");\n  } catch {\n    return null;\n  }\n}\nfunction extractTypeName(type) {\n  return (0, import_jsdoc_type_pratt_parser.transform)(jsdocStringifyRules, type);\n}\n\n// src/docs-tools/argTypes/utils.ts\nvar MAX_TYPE_SUMMARY_LENGTH = 90, MAX_DEFAULT_VALUE_SUMMARY_LENGTH = 50;\nfunction isTooLongForTypeSummary(value) {\n  return value.length > 90;\n}\nfunction isTooLongForDefaultValueSummary(value) {\n  return value.length > 50;\n}\nfunction createSummaryValue(summary, detail) {\n  return summary === detail ? { summary } : { summary, detail };\n}\nvar normalizeNewlines = (string) => string.replace(/\\\\r\\\\n/g, \"\\\\n\");\n\n// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts\nfunction createDefaultValue(defaultValue, type) {\n  if (defaultValue != null) {\n    let { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value))\n      return isTooLongForDefaultValueSummary(value) ? createSummaryValue(type?.name, value) : createSummaryValue(value);\n  }\n  return null;\n}\n\n// src/docs-tools/argTypes/docgen/flow/createType.ts\nfunction generateUnionElement({ name, value, elements, raw }) {\n  return value ?? (elements != null ? elements.map(generateUnionElement).join(\" | \") : raw ?? name);\n}\nfunction generateUnion({ name, raw, elements }) {\n  return elements != null ? createSummaryValue(elements.map(generateUnionElement).join(\" | \")) : raw != null ? createSummaryValue(raw.replace(/^\\|\\s*/, \"\")) : createSummaryValue(name);\n}\nfunction generateFuncSignature({ type, raw }) {\n  return raw != null ? createSummaryValue(raw) : createSummaryValue(type);\n}\nfunction generateObjectSignature({ type, raw }) {\n  return raw != null ? isTooLongForTypeSummary(raw) ? createSummaryValue(type, raw) : createSummaryValue(raw) : createSummaryValue(type);\n}\nfunction generateSignature(flowType) {\n  let { type } = flowType;\n  return type === \"object\" ? generateObjectSignature(flowType) : generateFuncSignature(flowType);\n}\nfunction generateDefault({ name, raw }) {\n  return raw != null ? isTooLongForTypeSummary(raw) ? createSummaryValue(name, raw) : createSummaryValue(raw) : createSummaryValue(name);\n}\nfunction createType(type) {\n  if (type == null)\n    return null;\n  switch (type.name) {\n    case \"union\" /* UNION */:\n      return generateUnion(type);\n    case \"signature\" /* SIGNATURE */:\n      return generateSignature(type);\n    default:\n      return generateDefault(type);\n  }\n}\n\n// src/docs-tools/argTypes/docgen/flow/createPropDef.ts\nvar createFlowPropDef = (propName, docgenInfo) => {\n  let { flowType, description, required, defaultValue } = docgenInfo;\n  return {\n    name: propName,\n    type: createType(flowType),\n    required,\n    description,\n    defaultValue: createDefaultValue(defaultValue ?? null, flowType ?? null)\n  };\n};\n\n// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts\nfunction createDefaultValue2({ defaultValue }) {\n  if (defaultValue != null) {\n    let { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value))\n      return createSummaryValue(value);\n  }\n  return null;\n}\n\n// src/docs-tools/argTypes/docgen/typeScript/createType.ts\nfunction createType2({ tsType, required }) {\n  if (tsType == null)\n    return null;\n  let typeName = tsType.name;\n  return required || (typeName = typeName.replace(\" | undefined\", \"\")), createSummaryValue(\n    [\"Array\", \"Record\", \"signature\"].includes(tsType.name) ? tsType.raw : typeName\n  );\n}\n\n// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts\nvar createTsPropDef = (propName, docgenInfo) => {\n  let { description, required } = docgenInfo;\n  return {\n    name: propName,\n    type: createType2(docgenInfo),\n    required,\n    description,\n    defaultValue: createDefaultValue2(docgenInfo)\n  };\n};\n\n// src/docs-tools/argTypes/docgen/createPropDef.ts\nfunction createType3(type) {\n  return type != null ? createSummaryValue(type.name) : null;\n}\nfunction isReactDocgenTypescript(defaultValue) {\n  let { computed, func } = defaultValue;\n  return typeof computed > \"u\" && typeof func > \"u\";\n}\nfunction isStringValued(type) {\n  return type ? type.name === \"string\" ? !0 : type.name === \"enum\" ? Array.isArray(type.value) && type.value.every(\n    ({ value: tv }) => typeof tv == \"string\" && tv[0] === '\"' && tv[tv.length - 1] === '\"'\n  ) : !1 : !1;\n}\nfunction createDefaultValue3(defaultValue, type) {\n  if (defaultValue != null) {\n    let { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value))\n      return isReactDocgenTypescript(defaultValue) && isStringValued(type) ? createSummaryValue(JSON.stringify(value)) : createSummaryValue(value);\n  }\n  return null;\n}\nfunction createBasicPropDef(name, type, docgenInfo) {\n  let { description, required, defaultValue } = docgenInfo;\n  return {\n    name,\n    type: createType3(type),\n    required,\n    description,\n    defaultValue: createDefaultValue3(defaultValue, type)\n  };\n}\nfunction applyJsDocResult(propDef, jsDocParsingResult) {\n  if (jsDocParsingResult?.includesJsDoc) {\n    let { description, extractedTags } = jsDocParsingResult;\n    description != null && (propDef.description = jsDocParsingResult.description);\n    let value = {\n      ...extractedTags,\n      params: extractedTags?.params?.map(\n        (x) => ({\n          name: x.getPrettyName(),\n          description: x.description\n        })\n      )\n    };\n    Object.values(value).filter(Boolean).length > 0 && (propDef.jsDocTags = value);\n  }\n  return propDef;\n}\nvar javaScriptFactory = (propName, docgenInfo, jsDocParsingResult) => {\n  let propDef = createBasicPropDef(propName, docgenInfo.type, docgenInfo);\n  return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);\n}, tsFactory = (propName, docgenInfo, jsDocParsingResult) => {\n  let propDef = createTsPropDef(propName, docgenInfo);\n  return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);\n}, flowFactory = (propName, docgenInfo, jsDocParsingResult) => {\n  let propDef = createFlowPropDef(propName, docgenInfo);\n  return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);\n}, unknownFactory = (propName, docgenInfo, jsDocParsingResult) => {\n  let propDef = createBasicPropDef(propName, { name: \"unknown\" }, docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, getPropDefFactory = (typeSystem) => {\n  switch (typeSystem) {\n    case \"JavaScript\" /* JAVASCRIPT */:\n      return javaScriptFactory;\n    case \"TypeScript\" /* TYPESCRIPT */:\n      return tsFactory;\n    case \"Flow\" /* FLOW */:\n      return flowFactory;\n    default:\n      return unknownFactory;\n  }\n};\n\n// src/docs-tools/argTypes/docgen/extractDocgenProps.ts\nvar getTypeSystem = (docgenInfo) => docgenInfo.type != null ? \"JavaScript\" /* JAVASCRIPT */ : docgenInfo.flowType != null ? \"Flow\" /* FLOW */ : docgenInfo.tsType != null ? \"TypeScript\" /* TYPESCRIPT */ : \"Unknown\" /* UNKNOWN */, extractComponentSectionArray = (docgenSection) => {\n  let typeSystem = getTypeSystem(docgenSection[0]), createPropDef = getPropDefFactory(typeSystem);\n  return docgenSection.map((item) => {\n    let sanitizedItem = item;\n    return item.type?.elements && (sanitizedItem = {\n      ...item,\n      type: {\n        ...item.type,\n        value: item.type.elements\n      }\n    }), extractProp(sanitizedItem.name, sanitizedItem, typeSystem, createPropDef);\n  });\n}, extractComponentSectionObject = (docgenSection) => {\n  let docgenPropsKeys = Object.keys(docgenSection), typeSystem = getTypeSystem(docgenSection[docgenPropsKeys[0]]), createPropDef = getPropDefFactory(typeSystem);\n  return docgenPropsKeys.map((propName) => {\n    let docgenInfo = docgenSection[propName];\n    return docgenInfo != null ? extractProp(propName, docgenInfo, typeSystem, createPropDef) : null;\n  }).filter(Boolean);\n}, extractComponentProps = (component, section) => {\n  let docgenSection = getDocgenSection(component, section);\n  return isValidDocgenSection(docgenSection) ? Array.isArray(docgenSection) ? extractComponentSectionArray(docgenSection) : extractComponentSectionObject(docgenSection) : [];\n};\nfunction extractProp(propName, docgenInfo, typeSystem, createPropDef) {\n  let jsDocParsingResult = parseJsDoc(docgenInfo.description);\n  return jsDocParsingResult.includesJsDoc && jsDocParsingResult.ignore ? null : {\n    propDef: createPropDef(propName, docgenInfo, jsDocParsingResult),\n    jsDocTags: jsDocParsingResult.extractedTags,\n    docgenInfo,\n    typeSystem\n  };\n}\nfunction extractComponentDescription(component) {\n  return component != null ? getDocgenDescription(component) : \"\";\n}\n\n// src/preview-api/modules/store/parameters.ts\nvar combineParameters = (...parameterSets) => {\n  let mergeKeys = {}, definedParametersSets = parameterSets.filter(Boolean), combined = definedParametersSets.reduce((acc, parameters) => (Object.entries(parameters).forEach(([key, value]) => {\n    let existing = acc[key];\n    Array.isArray(value) || typeof existing > \"u\" ? acc[key] = value : isPlainObject(value) && isPlainObject(existing) ? mergeKeys[key] = !0 : typeof value < \"u\" && (acc[key] = value);\n  }), acc), {});\n  return Object.keys(mergeKeys).forEach((key) => {\n    let mergeValues = definedParametersSets.filter(Boolean).map((p) => p[key]).filter((value) => typeof value < \"u\");\n    mergeValues.every((value) => isPlainObject(value)) ? combined[key] = combineParameters(...mergeValues) : combined[key] = mergeValues[mergeValues.length - 1];\n  }), combined;\n};\n\n// src/docs-tools/argTypes/enhanceArgTypes.ts\nvar enhanceArgTypes = (context) => {\n  let {\n    component,\n    argTypes: userArgTypes,\n    parameters: { docs = {} }\n  } = context, { extractArgTypes } = docs;\n  if (!extractArgTypes || !component)\n    return userArgTypes;\n  let extractedArgTypes = extractArgTypes(component);\n  return extractedArgTypes ? combineParameters(extractedArgTypes, userArgTypes) : userArgTypes;\n};\n\n// src/docs-tools/shared.ts\nvar ADDON_ID = \"storybook/docs\", PANEL_ID = `${ADDON_ID}/panel`, PARAM_KEY = \"docs\", SNIPPET_RENDERED = `${ADDON_ID}/snippet-rendered`, SourceType = /* @__PURE__ */ ((SourceType2) => (SourceType2.AUTO = \"auto\", SourceType2.CODE = \"code\", SourceType2.DYNAMIC = \"dynamic\", SourceType2))(SourceType || {});\n\nexport {\n  combineParameters,\n  convert4 as convert,\n  TypeSystem,\n  isDefaultValueBlacklisted,\n  str,\n  hasDocgen,\n  isValidDocgenSection,\n  getDocgenSection,\n  getDocgenDescription,\n  parseJsDoc,\n  MAX_TYPE_SUMMARY_LENGTH,\n  MAX_DEFAULT_VALUE_SUMMARY_LENGTH,\n  isTooLongForTypeSummary,\n  isTooLongForDefaultValueSummary,\n  createSummaryValue,\n  normalizeNewlines,\n  extractComponentSectionArray,\n  extractComponentSectionObject,\n  extractComponentProps,\n  extractComponentDescription,\n  enhanceArgTypes,\n  ADDON_ID,\n  PANEL_ID,\n  PARAM_KEY,\n  SNIPPET_RENDERED,\n  SourceType\n};\n"],
  "mappings": "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",
  "names": ["import_preview_errors", "__toESM"]
}
