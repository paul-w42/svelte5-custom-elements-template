import CJS_COMPAT_NODE_URL_0diydc4zf1f6 from 'node:url';
import CJS_COMPAT_NODE_PATH_0diydc4zf1f6 from 'node:path';
import CJS_COMPAT_NODE_MODULE_0diydc4zf1f6 from "node:module";

var __filename = CJS_COMPAT_NODE_URL_0diydc4zf1f6.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_0diydc4zf1f6.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_0diydc4zf1f6.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------

// src/plugins/svelte-docgen.ts
import { basename, relative } from "node:path";
import MagicString from "magic-string";

// src/plugins/generateDocgen.ts
import path from "node:path";
import svelte2tsx, { internalHelpers } from "svelte2tsx";
import { VERSION } from "svelte/compiler";
import ts from "typescript";
function convertType(type, checker) {
  if (type.flags & ts.TypeFlags.Any)
    return { type: "any" };
  if (type.flags & ts.TypeFlags.Number)
    return { type: "number" };
  if (type.flags & ts.TypeFlags.String)
    return { type: "string" };
  if (type.flags & ts.TypeFlags.Boolean)
    return { type: "boolean" };
  if (type.flags & ts.TypeFlags.ESSymbol)
    return { type: "symbol" };
  if (type.flags & ts.TypeFlags.Null)
    return { type: "null" };
  if (type.flags & ts.TypeFlags.Undefined)
    return { type: "undefined" };
  if (type.flags & ts.TypeFlags.Void)
    return { type: "void" };
  if (type.getCallSignatures().length > 0)
    return { type: "function", text: checker.typeToString(type) };
  if (type.flags & ts.TypeFlags.Object)
    return checker.getIndexTypeOfType(type, ts.IndexKind.Number) ? { type: "array", text: checker.typeToString(type) } : { type: "object", text: checker.typeToString(type) };
  if (type.isNumberLiteral() || type.isStringLiteral())
    return {
      type: "literal",
      value: type.value,
      text: type.flags & ts.TypeFlags.EnumLiteral ? checker.typeToString(type) : JSON.stringify(type.value)
    };
  if (type.flags & ts.TypeFlags.BooleanLiteral) {
    let text = checker.typeToString(type);
    return { type: "literal", value: text === "true", text };
  }
  if (type.isUnion()) {
    let types = type.types.map((t) => convertType(t, checker)).filter((t) => t !== void 0 && t.type !== "undefined"), idxTrue = types.findIndex((t) => t.type === "literal" && t.value === !0), idxFalse = types.findIndex((t) => t.type === "literal" && t.value === !1);
    return idxTrue !== -1 && idxFalse !== -1 && (types.splice(Math.max(idxTrue, idxFalse), 1), types.splice(Math.min(idxTrue, idxFalse), 1, { type: "boolean" })), types.length > 1 ? { type: "union", types } : types[0];
  }
  if (type.isIntersection())
    return { type: "intersection", types: type.types.map((t) => convertType(t, checker)).filter((t) => t !== void 0) };
}
function initializerToDefaultValue(expr, checker) {
  if (ts.isNumericLiteral(expr))
    return { text: expr.text };
  if (ts.isStringLiteral(expr))
    return { text: JSON.stringify(expr.text) };
  if (ts.isIdentifier(expr) || ts.isPropertyAccessExpression(expr)) {
    let symbol = checker.getSymbolAtLocation(expr);
    if (symbol && checker.isUndefinedSymbol(symbol))
      return;
    let type = checker.getTypeAtLocation(expr);
    if (type.flags & ts.TypeFlags.EnumLiteral)
      return { text: checker.typeToString(type) };
    if (type.isLiteral())
      return { text: JSON.stringify(type.value) };
    if (type.flags & ts.TypeFlags.Null)
      return { text: "null" };
    if (type.flags & ts.TypeFlags.BooleanLiteral)
      return { text: checker.typeToString(type) };
    if (type.getCallSignatures().length > 0)
      return { text: "function" };
  } else {
    if (ts.isArrayLiteralExpression(expr) || ts.isObjectLiteralExpression(expr) || ts.isNewExpression(expr))
      return { text: expr.getText() };
    if (ts.isArrowFunction(expr))
      return { text: "function" };
  }
  switch (expr.kind) {
    case ts.SyntaxKind.TrueKeyword:
      return { text: "true" };
    case ts.SyntaxKind.FalseKeyword:
      return { text: "false" };
    case ts.SyntaxKind.NullKeyword:
      return { text: "null" };
  }
  return { text: "..." };
}
function loadConfig(basepath) {
  let configPath = ts.findConfigFile(basepath, ts.sys.fileExists) || ts.findConfigFile(basepath, ts.sys.fileExists, "jsconfig.json"), forcedOptions = {
    sourceMap: !1,
    noEmit: !0,
    strict: !0,
    allowJs: !0,
    checkJs: !0,
    skipLibCheck: !0,
    skipDefaultLibCheck: !0
  };
  if (!configPath)
    return [forcedOptions, /* @__PURE__ */ new Set()];
  let configFile = ts.readConfigFile(configPath, ts.sys.readFile), config = ts.parseJsonConfigFileContent(
    configFile.config,
    ts.sys,
    path.dirname(configPath),
    void 0,
    configPath,
    void 0,
    [
      {
        extension: "svelte",
        isMixedContent: !0,
        scriptKind: ts.ScriptKind.Deferred
      }
    ]
  ), fileNames = new Set(
    config.fileNames.filter((fileName) => fileName.endsWith(".svelte")).map((fileName) => fileName + ".tsx")
  );
  return [
    {
      ...config.options,
      ...forcedOptions
    },
    fileNames
  ];
}
function createDocgenCache() {
  return {
    filenameToModifiedTime: {},
    filenameToSourceFile: {},
    fileCache: {}
  };
}
function generateDocgen(targetFileName, cache) {
  if (targetFileName.endsWith(".svelte") && (targetFileName = targetFileName + ".tsx"), cache.options === void 0 || !cache.rootNames?.has(targetFileName)) {
    [cache.options, cache.rootNames] = loadConfig(targetFileName);
    let shimFilename = import.meta.resolve("svelte2tsx/svelte-shims-v4.d.ts");
    cache.rootNames.add(shimFilename), cache.rootNames.add(targetFileName);
  }
  let originalHost = ts.createCompilerHost(cache.options), host = {
    ...originalHost,
    readFile(fileName) {
      let isCacheTarget = fileName.endsWith(path.sep + "package.json");
      if (isCacheTarget && cache.fileCache[fileName])
        return cache.fileCache[fileName];
      let content = originalHost.readFile(fileName);
      return content && isCacheTarget && (cache.fileCache[fileName] = content), content;
    },
    fileExists(fileName) {
      if (fileName.endsWith(path.sep + "package.json") && cache.fileCache[fileName])
        return !0;
      let exists = originalHost.fileExists(fileName);
      return exists || (fileName.endsWith(".svelte.tsx") || fileName.endsWith(".svelte.jsx") ? (fileName = fileName.slice(0, -4), exists = originalHost.fileExists(fileName), exists) : !1);
    },
    getSourceFile(fileName, languageVersion, onError) {
      if (fileName.endsWith(".svelte.tsx") || fileName.endsWith(".svelte.jsx")) {
        let realFileName = fileName.slice(0, -4), modifiedTime = ts.sys.getModifiedTime ? ts.sys.getModifiedTime(realFileName) : void 0;
        if (modifiedTime && cache.filenameToModifiedTime[fileName]?.getTime() === modifiedTime.getTime())
          return cache.filenameToSourceFile[fileName];
        let content = originalHost.readFile(realFileName);
        if (content === void 0)
          return;
        let isTsFile = /<script\s+[^>]*?lang=('|")(ts|typescript)('|")/.test(content), tsx = svelte2tsx.svelte2tsx(content, {
          version: VERSION,
          isTsFile,
          mode: "dts"
        }), sourceFile2 = ts.createSourceFile(
          fileName,
          tsx.code,
          languageVersion,
          !0,
          isTsFile ? ts.ScriptKind.TS : ts.ScriptKind.JS
          // Set to 'JS' to enable TypeScript to parse JSDoc.
        );
        return cache.filenameToSourceFile[fileName] = sourceFile2, cache.filenameToModifiedTime[fileName] = modifiedTime, sourceFile2;
      } else {
        let staticCaching = !1;
        staticCaching ||= fileName.split(path.sep).some((part) => part.toLowerCase() === "node_modules");
        let cachedSourceFile = cache.filenameToSourceFile[fileName];
        if (cachedSourceFile && staticCaching)
          return cachedSourceFile;
        let modifiedTime = ts.sys.getModifiedTime ? ts.sys.getModifiedTime(fileName) : void 0;
        if (modifiedTime && cache.filenameToModifiedTime[fileName]?.getTime() === modifiedTime.getTime())
          return cache.filenameToSourceFile[fileName];
        let content = originalHost.readFile(fileName);
        if (content === void 0)
          return;
        let sourceFile2 = ts.createSourceFile(fileName, content, languageVersion, !0);
        return cache.filenameToSourceFile[fileName] = sourceFile2, cache.filenameToModifiedTime[fileName] = modifiedTime, sourceFile2;
      }
    },
    writeFile() {
    }
  }, program = ts.createProgram({
    rootNames: Array.from(cache.rootNames),
    options: cache.options,
    host,
    oldProgram: cache.oldProgram
  });
  cache.oldProgram = program;
  let checker = program.getTypeChecker(), sourceFile = program.getSourceFile(targetFileName);
  if (sourceFile === void 0)
    return {
      props: []
    };
  let propMap = /* @__PURE__ */ new Map(), renderFunction = sourceFile.statements.find((statement) => ts.isFunctionDeclaration(statement) && statement.name?.text === internalHelpers.renderName);
  if (renderFunction === void 0)
    return {
      props: []
    };
  let propsType, signature = checker.getSignatureFromDeclaration(renderFunction);
  return signature && signature.declaration && checker.getReturnTypeOfSignature(signature).getProperties().forEach((retObjProp) => {
    if (retObjProp.name === "props") {
      let decl = signature.getDeclaration();
      propsType = checker.getTypeOfSymbolAtLocation(retObjProp, decl), propsType.getProperties().forEach((prop) => {
        let name = prop.getName(), description = ts.displayPartsToString(prop.getDocumentationComment(checker)) || void 0, propType = checker.getTypeOfSymbolAtLocation(prop, decl);
        if (prop.valueDeclaration) {
          let typeTag = ts.getJSDocTypeTag(prop.valueDeclaration);
          typeTag?.comment && (description = ((description || "") + `
` + typeTag.comment).trim());
        }
        if ((prop.valueDeclaration ?? prop?.links?.syntheticOrigin?.valueDeclaration)?.getSourceFile().fileName.includes("node_modules/svelte/elements.d.ts"))
          return;
        let optional = (prop.flags & ts.SymbolFlags.Optional) !== 0;
        propMap.set(name, {
          name,
          optional,
          description,
          type: convertType(propType, checker)
        });
      });
    }
  }), renderFunction.body?.forEachChild((node) => {
    ts.isVariableStatement(node) && node.declarationList.declarations.forEach((declaration) => {
      if (ts.isObjectBindingPattern(declaration.name)) {
        let isPropsRune = declaration.initializer && ts.isCallExpression(declaration.initializer) && ts.isIdentifier(declaration.initializer.expression) && declaration.initializer.expression.text === "$props", isPropsType = declaration.type && propsType === checker.getTypeFromTypeNode(declaration.type);
        (isPropsRune || isPropsType) && declaration.name.elements.forEach((element) => {
          let name = element.name.getText(), prop = propMap.get(name);
          if (prop && element.initializer) {
            let defaultValue = initializerToDefaultValue(element.initializer, checker);
            defaultValue && (prop.defaultValue = defaultValue);
          }
        });
      }
      if (ts.isVariableDeclaration(declaration) && ts.isIdentifier(declaration.name) && propMap.has(declaration.name.text)) {
        let prop = propMap.get(declaration.name.text);
        if (prop && declaration.initializer) {
          prop.optional = !0;
          let defaultValue = initializerToDefaultValue(declaration.initializer, checker);
          defaultValue && (prop.defaultValue = defaultValue);
        }
      }
    });
  }), {
    props: Array.from(propMap.values())
  };
}

// src/plugins/svelte-docgen.ts
function getComponentName(ast) {
  let exportDefaultDeclaration = ast.body.find((n) => n.type === "ExportDefaultDeclaration");
  if (!exportDefaultDeclaration)
    throw new Error("Unreachable - no default export found");
  if (exportDefaultDeclaration.declaration.type === "Identifier")
    return exportDefaultDeclaration.declaration.name;
  if (exportDefaultDeclaration.declaration.type !== "ClassDeclaration" && exportDefaultDeclaration.declaration.type !== "FunctionDeclaration")
    throw new Error("Unreachable - not a class or a function");
  if (!exportDefaultDeclaration.declaration.id)
    throw new Error("Unreachable - unnamed class/function");
  return exportDefaultDeclaration.declaration.id.name;
}
function transformToSvelteDocParserType(type) {
  switch (type.type) {
    case "string":
      return { kind: "type", type: "string", text: "string" };
    case "number":
      return { kind: "type", type: "number", text: "number" };
    case "boolean":
      return { kind: "type", type: "boolean", text: "boolean" };
    case "symbol":
      return { kind: "type", type: "other", text: "symbol" };
    case "null":
      return { kind: "type", type: "other", text: "null" };
    case "undefined":
      return { kind: "type", type: "other", text: "undefined" };
    case "void":
      return { kind: "type", type: "other", text: "void" };
    case "any":
      return { kind: "type", type: "any", text: "any" };
    case "object":
      return { kind: "type", type: "object", text: type.text };
    case "array":
      return { kind: "type", type: "array", text: type.text };
    case "function":
      return { kind: "function", text: type.text };
    case "literal":
      return { kind: "const", type: typeof type.value, value: type.value, text: type.text };
    case "union": {
      let nonNull = type.types.filter((t) => t.type !== "null"), text = nonNull.map((t) => transformToSvelteDocParserType(t).text).join(" | "), types = nonNull.map((t) => transformToSvelteDocParserType(t));
      return types.length === 1 ? types[0] : { kind: "union", type: types, text };
    }
    case "intersection":
      return { kind: "type", type: "intersection", text: type.types.map((t) => transformToSvelteDocParserType(t).text).join(" & ") };
  }
}
function transformToSvelteDocParserDataItems(docgen) {
  return docgen.props.map((p) => {
    let required = p.optional === !1 && p.defaultValue === void 0;
    return {
      name: p.name,
      visibility: "public",
      description: p.description,
      keywords: required ? [{ name: "required", description: "" }] : [],
      kind: "let",
      type: p.type ? transformToSvelteDocParserType(p.type) : void 0,
      static: !1,
      readonly: !1,
      importPath: void 0,
      originalName: void 0,
      localName: void 0,
      defaultValue: p.defaultValue ? p.defaultValue.text : void 0
    };
  });
}
async function svelteDocgen() {
  let cwd = process.cwd(), include = /\.svelte$/, exclude = /node_modules\/.*/, { createFilter } = await import("vite"), filter = createFilter(include, exclude), sourceFileCache = createDocgenCache();
  return {
    name: "storybook:svelte-docgen-plugin",
    async transform(src, id) {
      if (id.startsWith("\0") || !filter(id))
        return;
      let resource = relative(cwd, id), docgen = generateDocgen(resource, sourceFileCache), componentDoc = {
        data: transformToSvelteDocParserDataItems(docgen),
        name: basename(resource)
      }, s = new MagicString(src), outputAst = this.parse(src), componentName = getComponentName(outputAst);
      return s.append(`
;${componentName}.__docgen = ${JSON.stringify(componentDoc)}`), {
        code: s.toString(),
        map: s.generateMap({ hires: !0, source: id })
      };
    }
  };
}

// src/utils.ts
import { SvelteViteWithSvelteKitError } from "storybook/internal/server-errors";
import { hasVitePlugins } from "@storybook/builder-vite";
async function handleSvelteKit(plugins, options) {
  let frameworkPreset = await options.presets.apply("framework", {}, options), framework = typeof frameworkPreset == "string" ? frameworkPreset : frameworkPreset.name;
  if (await hasVitePlugins(plugins, [
    "vite-plugin-svelte-kit",
    "vite-plugin-sveltekit-setup",
    "vite-plugin-sveltekit-compile"
  ]) && !framework.includes("@storybook/sveltekit"))
    throw new SvelteViteWithSvelteKitError();
}

// src/preset.ts
var core = {
  builder: import.meta.resolve("@storybook/builder-vite"),
  renderer: import.meta.resolve("@storybook/svelte/preset")
}, viteFinal = async (config, options) => {
  let { plugins = [] } = config, framework = await options.presets.apply("framework");
  return (typeof framework == "string" ? {} : framework.options ?? {}).docgen !== !1 && plugins.push(await svelteDocgen()), await handleSvelteKit(plugins, options), {
    ...config,
    plugins
  };
};
export {
  core,
  viteFinal
};
